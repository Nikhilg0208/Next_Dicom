"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_cornerstonejs_dicom-image-loader_dist_esm_codecs_jpeg_js"],{

/***/ "(app-pages-browser)/./node_modules/@cornerstonejs/dicom-image-loader/dist/esm/codecs/jpeg.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@cornerstonejs/dicom-image-loader/dist/esm/codecs/jpeg.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar ColorSpace = { Unkown: 0, Grayscale: 1, AdobeRGB: 2, RGB: 3, CYMK: 4 };\nvar dctZigZag = new Int32Array([\n    0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40,\n    48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29,\n    22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,\n    47, 55, 62, 63,\n]);\nvar dctCos1 = 4017;\nvar dctSin1 = 799;\nvar dctCos3 = 3406;\nvar dctSin3 = 2276;\nvar dctCos6 = 1567;\nvar dctSin6 = 3784;\nvar dctSqrt2 = 5793;\nvar dctSqrt1d2 = 2896;\nfunction buildHuffmanTable(codeLengths, values) {\n    var k = 0, code = [], i, j, length = 16;\n    while (length > 0 && !codeLengths[length - 1])\n        length--;\n    code.push({ children: [], index: 0 });\n    var p = code[0], q;\n    for (i = 0; i < length; i++) {\n        for (j = 0; j < codeLengths[i]; j++) {\n            p = code.pop();\n            p.children[p.index] = values[k];\n            while (p.index > 0) {\n                p = code.pop();\n            }\n            p.index++;\n            code.push(p);\n            while (code.length <= i) {\n                code.push((q = { children: [], index: 0 }));\n                p.children[p.index] = q.children;\n                p = q;\n            }\n            k++;\n        }\n        if (i + 1 < length) {\n            code.push((q = { children: [], index: 0 }));\n            p.children[p.index] = q.children;\n            p = q;\n        }\n    }\n    return code[0].children;\n}\nfunction getBlockBufferOffset(component, row, col) {\n    return 64 * ((component.blocksPerLine + 1) * row + col);\n}\nfunction decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH, maxV = frame.maxV;\n    var startOffset = offset, bitsData = 0, bitsCount = 0;\n    function readBit() {\n        if (bitsCount > 0) {\n            bitsCount--;\n            return (bitsData >> bitsCount) & 1;\n        }\n        bitsData = data[offset++];\n        if (bitsData == 0xff) {\n            var nextByte = data[offset++];\n            if (nextByte) {\n                throw 'unexpected marker: ' + ((bitsData << 8) | nextByte).toString(16);\n            }\n        }\n        bitsCount = 7;\n        return bitsData >>> 7;\n    }\n    function decodeHuffman(tree) {\n        var node = tree;\n        var bit;\n        while ((bit = readBit()) !== null) {\n            node = node[bit];\n            if (typeof node === 'number')\n                return node;\n            if (typeof node !== 'object')\n                throw 'invalid huffman sequence';\n        }\n        return null;\n    }\n    function receive(length) {\n        var n = 0;\n        while (length > 0) {\n            var bit = readBit();\n            if (bit === null)\n                return;\n            n = (n << 1) | bit;\n            length--;\n        }\n        return n;\n    }\n    function receiveAndExtend(length) {\n        var n = receive(length);\n        if (n >= 1 << (length - 1))\n            return n;\n        return n + (-1 << length) + 1;\n    }\n    function decodeBaseline(component, offset) {\n        var t = decodeHuffman(component.huffmanTableDC);\n        var diff = t === 0 ? 0 : receiveAndExtend(t);\n        component.blockData[offset] = component.pred += diff;\n        var k = 1;\n        while (k < 64) {\n            var rs = decodeHuffman(component.huffmanTableAC);\n            var s = rs & 15, r = rs >> 4;\n            if (s === 0) {\n                if (r < 15)\n                    break;\n                k += 16;\n                continue;\n            }\n            k += r;\n            var z = dctZigZag[k];\n            component.blockData[offset + z] = receiveAndExtend(s);\n            k++;\n        }\n    }\n    function decodeDCFirst(component, offset) {\n        var t = decodeHuffman(component.huffmanTableDC);\n        var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;\n        component.blockData[offset] = component.pred += diff;\n    }\n    function decodeDCSuccessive(component, offset) {\n        component.blockData[offset] |= readBit() << successive;\n    }\n    var eobrun = 0;\n    function decodeACFirst(component, offset) {\n        if (eobrun > 0) {\n            eobrun--;\n            return;\n        }\n        var k = spectralStart, e = spectralEnd;\n        while (k <= e) {\n            var rs = decodeHuffman(component.huffmanTableAC);\n            var s = rs & 15, r = rs >> 4;\n            if (s === 0) {\n                if (r < 15) {\n                    eobrun = receive(r) + (1 << r) - 1;\n                    break;\n                }\n                k += 16;\n                continue;\n            }\n            k += r;\n            var z = dctZigZag[k];\n            component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);\n            k++;\n        }\n    }\n    var successiveACState = 0, successiveACNextValue;\n    function decodeACSuccessive(component, offset) {\n        var k = spectralStart, e = spectralEnd, r = 0;\n        while (k <= e) {\n            var z = dctZigZag[k];\n            switch (successiveACState) {\n                case 0:\n                    var rs = decodeHuffman(component.huffmanTableAC);\n                    var s = rs & 15;\n                    r = rs >> 4;\n                    if (s === 0) {\n                        if (r < 15) {\n                            eobrun = receive(r) + (1 << r);\n                            successiveACState = 4;\n                        }\n                        else {\n                            r = 16;\n                            successiveACState = 1;\n                        }\n                    }\n                    else {\n                        if (s !== 1)\n                            throw 'invalid ACn encoding';\n                        successiveACNextValue = receiveAndExtend(s);\n                        successiveACState = r ? 2 : 3;\n                    }\n                    continue;\n                case 1:\n                case 2:\n                    if (component.blockData[offset + z]) {\n                        component.blockData[offset + z] += readBit() << successive;\n                    }\n                    else {\n                        r--;\n                        if (r === 0)\n                            successiveACState = successiveACState == 2 ? 3 : 0;\n                    }\n                    break;\n                case 3:\n                    if (component.blockData[offset + z]) {\n                        component.blockData[offset + z] += readBit() << successive;\n                    }\n                    else {\n                        component.blockData[offset + z] =\n                            successiveACNextValue << successive;\n                        successiveACState = 0;\n                    }\n                    break;\n                case 4:\n                    if (component.blockData[offset + z]) {\n                        component.blockData[offset + z] += readBit() << successive;\n                    }\n                    break;\n            }\n            k++;\n        }\n        if (successiveACState === 4) {\n            eobrun--;\n            if (eobrun === 0)\n                successiveACState = 0;\n        }\n    }\n    function decodeMcu(component, decode, mcu, row, col) {\n        var mcuRow = (mcu / mcusPerLine) | 0;\n        var mcuCol = mcu % mcusPerLine;\n        var blockRow = mcuRow * component.v + row;\n        var blockCol = mcuCol * component.h + col;\n        var offset = getBlockBufferOffset(component, blockRow, blockCol);\n        decode(component, offset);\n    }\n    function decodeBlock(component, decode, mcu) {\n        var blockRow = (mcu / component.blocksPerLine) | 0;\n        var blockCol = mcu % component.blocksPerLine;\n        var offset = getBlockBufferOffset(component, blockRow, blockCol);\n        decode(component, offset);\n    }\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n    if (progressive) {\n        if (spectralStart === 0)\n            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n        else\n            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    }\n    else {\n        decodeFn = decodeBaseline;\n    }\n    var mcu = 0, marker;\n    var mcuExpected;\n    if (componentsLength == 1) {\n        mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    }\n    else {\n        mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n    if (!resetInterval) {\n        resetInterval = mcuExpected;\n    }\n    var h, v;\n    while (mcu < mcuExpected) {\n        for (i = 0; i < componentsLength; i++) {\n            components[i].pred = 0;\n        }\n        eobrun = 0;\n        if (componentsLength == 1) {\n            component = components[0];\n            for (n = 0; n < resetInterval; n++) {\n                decodeBlock(component, decodeFn, mcu);\n                mcu++;\n            }\n        }\n        else {\n            for (n = 0; n < resetInterval; n++) {\n                for (i = 0; i < componentsLength; i++) {\n                    component = components[i];\n                    h = component.h;\n                    v = component.v;\n                    for (j = 0; j < v; j++) {\n                        for (k = 0; k < h; k++) {\n                            decodeMcu(component, decodeFn, mcu, j, k);\n                        }\n                    }\n                }\n                mcu++;\n            }\n        }\n        bitsCount = 0;\n        marker = (data[offset] << 8) | data[offset + 1];\n        if (marker <= 0xff00) {\n            throw 'marker was not found';\n        }\n        if (marker >= 0xffd0 && marker <= 0xffd7) {\n            offset += 2;\n        }\n        else {\n            break;\n        }\n    }\n    return offset - startOffset;\n}\nfunction quantizeAndInverse(component, blockBufferOffset, p) {\n    var qt = component.quantizationTable;\n    var v0, v1, v2, v3, v4, v5, v6, v7, t;\n    var i;\n    for (i = 0; i < 64; i++) {\n        p[i] = component.blockData[blockBufferOffset + i] * qt[i];\n    }\n    for (i = 0; i < 8; ++i) {\n        var row = 8 * i;\n        if (p[1 + row] === 0 &&\n            p[2 + row] === 0 &&\n            p[3 + row] === 0 &&\n            p[4 + row] === 0 &&\n            p[5 + row] === 0 &&\n            p[6 + row] === 0 &&\n            p[7 + row] === 0) {\n            t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n            p[0 + row] = t;\n            p[1 + row] = t;\n            p[2 + row] = t;\n            p[3 + row] = t;\n            p[4 + row] = t;\n            p[5 + row] = t;\n            p[6 + row] = t;\n            p[7 + row] = t;\n            continue;\n        }\n        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4;\n        t = (v0 - v1 + 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n    }\n    for (i = 0; i < 8; ++i) {\n        var col = i;\n        if (p[1 * 8 + col] === 0 &&\n            p[2 * 8 + col] === 0 &&\n            p[3 * 8 + col] === 0 &&\n            p[4 * 8 + col] === 0 &&\n            p[5 * 8 + col] === 0 &&\n            p[6 * 8 + col] === 0 &&\n            p[7 * 8 + col] === 0) {\n            t = (dctSqrt2 * p[i + 0] + 8192) >> 14;\n            p[0 * 8 + col] = t;\n            p[1 * 8 + col] = t;\n            p[2 * 8 + col] = t;\n            p[3 * 8 + col] = t;\n            p[4 * 8 + col] = t;\n            p[5 * 8 + col] = t;\n            p[6 * 8 + col] = t;\n            p[7 * 8 + col] = t;\n            continue;\n        }\n        v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) >> 12;\n        v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) >> 12;\n        v2 = p[2 * 8 + col];\n        v3 = p[6 * 8 + col];\n        v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) >> 12;\n        v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) >> 12;\n        v5 = p[3 * 8 + col];\n        v6 = p[5 * 8 + col];\n        t = (v0 - v1 + 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n        p[0 * 8 + col] = v0 + v7;\n        p[7 * 8 + col] = v0 - v7;\n        p[1 * 8 + col] = v1 + v6;\n        p[6 * 8 + col] = v1 - v6;\n        p[2 * 8 + col] = v2 + v5;\n        p[5 * 8 + col] = v2 - v5;\n        p[3 * 8 + col] = v3 + v4;\n        p[4 * 8 + col] = v3 - v4;\n    }\n    for (i = 0; i < 64; ++i) {\n        var index = blockBufferOffset + i;\n        var q = p[i];\n        q =\n            q <= -2056 / component.bitConversion\n                ? 0\n                : q >= 2024 / component.bitConversion\n                    ? 255 / component.bitConversion\n                    : (q + 2056 / component.bitConversion) >> 4;\n        component.blockData[index] = q;\n    }\n}\nfunction buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3;\n    var computationBuffer = new Int32Array(64);\n    var i, j, ll = 0;\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n        for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n            var offset = getBlockBufferOffset(component, blockRow, blockCol);\n            quantizeAndInverse(component, offset, computationBuffer);\n        }\n    }\n    return component.blockData;\n}\nfunction clampToUint8(a) {\n    return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;\n}\nclass JpegImage {\n    constructor() { }\n    load(path) {\n        var handleData = function (data) {\n            this.parse(data);\n            if (this.onload)\n                this.onload();\n        }.bind(this);\n        if (path.indexOf('data:') > -1) {\n            var offset = path.indexOf('base64,') + 7;\n            var data = atob(path.substring(offset));\n            var arr = new Uint8Array(data.length);\n            for (var i = data.length - 1; i >= 0; i--) {\n                arr[i] = data.charCodeAt(i);\n            }\n            handleData(data);\n        }\n        else {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', path, true);\n            xhr.responseType = 'arraybuffer';\n            xhr.onload = function () {\n                var data = new Uint8Array(xhr.response);\n                handleData(data);\n            }.bind(this);\n            xhr.send(null);\n        }\n    }\n    parse(data) {\n        function readUint16() {\n            var value = (data[offset] << 8) | data[offset + 1];\n            offset += 2;\n            return value;\n        }\n        function readDataBlock() {\n            var length = readUint16();\n            var array = data.subarray(offset, offset + length - 2);\n            offset += array.length;\n            return array;\n        }\n        function prepareComponents(frame) {\n            var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);\n            var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);\n            for (var i = 0; i < frame.components.length; i++) {\n                component = frame.components[i];\n                var blocksPerLine = Math.ceil((Math.ceil(frame.samplesPerLine / 8) * component.h) / frame.maxH);\n                var blocksPerColumn = Math.ceil((Math.ceil(frame.scanLines / 8) * component.v) / frame.maxV);\n                var blocksPerLineForMcu = mcusPerLine * component.h;\n                var blocksPerColumnForMcu = mcusPerColumn * component.v;\n                var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);\n                component.blockData = new Int16Array(blocksBufferSize);\n                component.blocksPerLine = blocksPerLine;\n                component.blocksPerColumn = blocksPerColumn;\n            }\n            frame.mcusPerLine = mcusPerLine;\n            frame.mcusPerColumn = mcusPerColumn;\n        }\n        var offset = 0, length = data.length;\n        var jfif = null;\n        var adobe = null;\n        var pixels = null;\n        var frame, resetInterval;\n        var quantizationTables = [];\n        var huffmanTablesAC = [], huffmanTablesDC = [];\n        var fileMarker = readUint16();\n        if (fileMarker != 0xffd8) {\n            throw 'SOI not found';\n        }\n        fileMarker = readUint16();\n        while (fileMarker != 0xffd9) {\n            var i, j, l;\n            switch (fileMarker) {\n                case 0xffe0:\n                case 0xffe1:\n                case 0xffe2:\n                case 0xffe3:\n                case 0xffe4:\n                case 0xffe5:\n                case 0xffe6:\n                case 0xffe7:\n                case 0xffe8:\n                case 0xffe9:\n                case 0xffea:\n                case 0xffeb:\n                case 0xffec:\n                case 0xffed:\n                case 0xffee:\n                case 0xffef:\n                case 0xfffe:\n                    var appData = readDataBlock();\n                    if (fileMarker === 0xffe0) {\n                        if (appData[0] === 0x4a &&\n                            appData[1] === 0x46 &&\n                            appData[2] === 0x49 &&\n                            appData[3] === 0x46 &&\n                            appData[4] === 0) {\n                            jfif = {\n                                version: { major: appData[5], minor: appData[6] },\n                                densityUnits: appData[7],\n                                xDensity: (appData[8] << 8) | appData[9],\n                                yDensity: (appData[10] << 8) | appData[11],\n                                thumbWidth: appData[12],\n                                thumbHeight: appData[13],\n                                thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13]),\n                            };\n                        }\n                    }\n                    if (fileMarker === 0xffee) {\n                        if (appData[0] === 0x41 &&\n                            appData[1] === 0x64 &&\n                            appData[2] === 0x6f &&\n                            appData[3] === 0x62 &&\n                            appData[4] === 0x65 &&\n                            appData[5] === 0) {\n                            adobe = {\n                                version: appData[6],\n                                flags0: (appData[7] << 8) | appData[8],\n                                flags1: (appData[9] << 8) | appData[10],\n                                transformCode: appData[11],\n                            };\n                        }\n                    }\n                    break;\n                case 0xffdb:\n                    var quantizationTablesLength = readUint16();\n                    var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n                    while (offset < quantizationTablesEnd) {\n                        var quantizationTableSpec = data[offset++];\n                        var tableData = new Int32Array(64);\n                        if (quantizationTableSpec >> 4 === 0) {\n                            for (j = 0; j < 64; j++) {\n                                var z = dctZigZag[j];\n                                tableData[z] = data[offset++];\n                            }\n                        }\n                        else if (quantizationTableSpec >> 4 === 1) {\n                            for (j = 0; j < 64; j++) {\n                                var zz = dctZigZag[j];\n                                tableData[zz] = readUint16();\n                            }\n                        }\n                        else\n                            throw 'DQT: invalid table spec';\n                        quantizationTables[quantizationTableSpec & 15] = tableData;\n                    }\n                    break;\n                case 0xffc0:\n                case 0xffc1:\n                case 0xffc2:\n                    if (frame) {\n                        throw 'Only single frame JPEGs supported';\n                    }\n                    readUint16();\n                    frame = {};\n                    frame.extended = fileMarker === 0xffc1;\n                    frame.progressive = fileMarker === 0xffc2;\n                    frame.precision = data[offset++];\n                    frame.scanLines = readUint16();\n                    frame.samplesPerLine = readUint16();\n                    frame.components = [];\n                    frame.componentIds = {};\n                    var componentsCount = data[offset++], componentId;\n                    var maxH = 0, maxV = 0;\n                    for (i = 0; i < componentsCount; i++) {\n                        componentId = data[offset];\n                        var h = data[offset + 1] >> 4;\n                        var v = data[offset + 1] & 15;\n                        if (maxH < h)\n                            maxH = h;\n                        if (maxV < v)\n                            maxV = v;\n                        var qId = data[offset + 2];\n                        l = frame.components.push({\n                            h: h,\n                            v: v,\n                            quantizationTable: quantizationTables[qId],\n                            quantizationTableId: qId,\n                            bitConversion: 255 / ((1 << frame.precision) - 1),\n                        });\n                        frame.componentIds[componentId] = l - 1;\n                        offset += 3;\n                    }\n                    frame.maxH = maxH;\n                    frame.maxV = maxV;\n                    prepareComponents(frame);\n                    break;\n                case 0xffc4:\n                    var huffmanLength = readUint16();\n                    for (i = 2; i < huffmanLength;) {\n                        var huffmanTableSpec = data[offset++];\n                        var codeLengths = new Uint8Array(16);\n                        var codeLengthSum = 0;\n                        for (j = 0; j < 16; j++, offset++)\n                            codeLengthSum += codeLengths[j] = data[offset];\n                        var huffmanValues = new Uint8Array(codeLengthSum);\n                        for (j = 0; j < codeLengthSum; j++, offset++)\n                            huffmanValues[j] = data[offset];\n                        i += 17 + codeLengthSum;\n                        (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n                    }\n                    break;\n                case 0xffdd:\n                    readUint16();\n                    resetInterval = readUint16();\n                    break;\n                case 0xffda:\n                    var scanLength = readUint16();\n                    var selectorsCount = data[offset++];\n                    var components = [], component;\n                    for (i = 0; i < selectorsCount; i++) {\n                        var componentIndex = frame.componentIds[data[offset++]];\n                        component = frame.components[componentIndex];\n                        var tableSpec = data[offset++];\n                        component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n                        component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n                        components.push(component);\n                    }\n                    var spectralStart = data[offset++];\n                    var spectralEnd = data[offset++];\n                    var successiveApproximation = data[offset++];\n                    var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);\n                    offset += processed;\n                    break;\n                case 0xffff:\n                    if (data[offset] !== 0xff) {\n                        offset--;\n                    }\n                    break;\n                default:\n                    if (data[offset - 3] == 0xff &&\n                        data[offset - 2] >= 0xc0 &&\n                        data[offset - 2] <= 0xfe) {\n                        offset -= 3;\n                        break;\n                    }\n                    throw 'unknown JPEG marker ' + fileMarker.toString(16);\n            }\n            fileMarker = readUint16();\n        }\n        this.width = frame.samplesPerLine;\n        this.height = frame.scanLines;\n        this.jfif = jfif;\n        this.adobe = adobe;\n        this.components = [];\n        switch (frame.components.length) {\n            case 1:\n                this.colorspace = ColorSpace.Grayscale;\n                break;\n            case 3:\n                if (this.adobe)\n                    this.colorspace = ColorSpace.AdobeRGB;\n                else\n                    this.colorspace = ColorSpace.RGB;\n                break;\n            case 4:\n                this.colorspace = ColorSpace.CYMK;\n                break;\n            default:\n                this.colorspace = ColorSpace.Unknown;\n        }\n        for (var i = 0; i < frame.components.length; i++) {\n            var component = frame.components[i];\n            if (!component.quantizationTable &&\n                component.quantizationTableId !== null)\n                component.quantizationTable =\n                    quantizationTables[component.quantizationTableId];\n            this.components.push({\n                output: buildComponentData(frame, component),\n                scaleX: component.h / frame.maxH,\n                scaleY: component.v / frame.maxV,\n                blocksPerLine: component.blocksPerLine,\n                blocksPerColumn: component.blocksPerColumn,\n                bitConversion: component.bitConversion,\n            });\n        }\n    }\n    getData16(width, height) {\n        if (this.components.length !== 1)\n            throw 'Unsupported color mode';\n        var scaleX = this.width / width, scaleY = this.height / height;\n        var component, componentScaleX, componentScaleY;\n        var x, y, i;\n        var offset = 0;\n        var numComponents = this.components.length;\n        var dataLength = width * height * numComponents;\n        var data = new Uint16Array(dataLength);\n        var componentLine;\n        var lineData = new Uint16Array((this.components[0].blocksPerLine << 3) *\n            this.components[0].blocksPerColumn *\n            8);\n        for (i = 0; i < numComponents; i++) {\n            component = this.components[i];\n            var blocksPerLine = component.blocksPerLine;\n            var blocksPerColumn = component.blocksPerColumn;\n            var samplesPerLine = blocksPerLine << 3;\n            var j, k, ll = 0;\n            var lineOffset = 0;\n            for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n                var scanLine = blockRow << 3;\n                for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                    var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);\n                    var offset = 0, sample = blockCol << 3;\n                    for (j = 0; j < 8; j++) {\n                        var lineOffset = (scanLine + j) * samplesPerLine;\n                        for (k = 0; k < 8; k++) {\n                            lineData[lineOffset + sample + k] =\n                                component.output[bufferOffset + offset++];\n                        }\n                    }\n                }\n            }\n            componentScaleX = component.scaleX * scaleX;\n            componentScaleY = component.scaleY * scaleY;\n            offset = i;\n            var cx, cy;\n            var index;\n            for (y = 0; y < height; y++) {\n                for (x = 0; x < width; x++) {\n                    cy = 0 | (y * componentScaleY);\n                    cx = 0 | (x * componentScaleX);\n                    index = cy * samplesPerLine + cx;\n                    data[offset] = lineData[index];\n                    offset += numComponents;\n                }\n            }\n        }\n        return data;\n    }\n    getData(width, height) {\n        var scaleX = this.width / width, scaleY = this.height / height;\n        var component, componentScaleX, componentScaleY;\n        var x, y, i;\n        var offset = 0;\n        var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n        var colorTransform;\n        var numComponents = this.components.length;\n        var dataLength = width * height * numComponents;\n        var data = new Uint8Array(dataLength);\n        var componentLine;\n        var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *\n            this.components[0].blocksPerColumn *\n            8);\n        for (i = 0; i < numComponents; i++) {\n            component = this.components[i];\n            var blocksPerLine = component.blocksPerLine;\n            var blocksPerColumn = component.blocksPerColumn;\n            var samplesPerLine = blocksPerLine << 3;\n            var j, k, ll = 0;\n            var lineOffset = 0;\n            for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n                var scanLine = blockRow << 3;\n                for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                    var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);\n                    var offset = 0, sample = blockCol << 3;\n                    for (j = 0; j < 8; j++) {\n                        var lineOffset = (scanLine + j) * samplesPerLine;\n                        for (k = 0; k < 8; k++) {\n                            lineData[lineOffset + sample + k] =\n                                component.output[bufferOffset + offset++] *\n                                    component.bitConversion;\n                        }\n                    }\n                }\n            }\n            componentScaleX = component.scaleX * scaleX;\n            componentScaleY = component.scaleY * scaleY;\n            offset = i;\n            var cx, cy;\n            var index;\n            for (y = 0; y < height; y++) {\n                for (x = 0; x < width; x++) {\n                    cy = 0 | (y * componentScaleY);\n                    cx = 0 | (x * componentScaleX);\n                    index = cy * samplesPerLine + cx;\n                    data[offset] = lineData[index];\n                    offset += numComponents;\n                }\n            }\n        }\n        switch (numComponents) {\n            case 1:\n            case 2:\n                break;\n            case 3:\n                colorTransform = true;\n                if (this.adobe && this.adobe.transformCode)\n                    colorTransform = true;\n                else if (typeof this.colorTransform !== 'undefined')\n                    colorTransform = !!this.colorTransform;\n                if (colorTransform) {\n                    for (i = 0; i < dataLength; i += numComponents) {\n                        Y = data[i];\n                        Cb = data[i + 1];\n                        Cr = data[i + 2];\n                        R = clampToUint8(Y - 179.456 + 1.402 * Cr);\n                        G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);\n                        B = clampToUint8(Y - 226.816 + 1.772 * Cb);\n                        data[i] = R;\n                        data[i + 1] = G;\n                        data[i + 2] = B;\n                    }\n                }\n                break;\n            case 4:\n                if (!this.adobe)\n                    throw 'Unsupported color mode (4 components)';\n                colorTransform = false;\n                if (this.adobe && this.adobe.transformCode)\n                    colorTransform = true;\n                else if (typeof this.colorTransform !== 'undefined')\n                    colorTransform = !!this.colorTransform;\n                if (colorTransform) {\n                    for (i = 0; i < dataLength; i += numComponents) {\n                        Y = data[i];\n                        Cb = data[i + 1];\n                        Cr = data[i + 2];\n                        C = clampToUint8(434.456 - Y - 1.402 * Cr);\n                        M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);\n                        Y = clampToUint8(481.816 - Y - 1.772 * Cb);\n                        data[i] = C;\n                        data[i + 1] = M;\n                        data[i + 2] = Y;\n                    }\n                }\n                break;\n            default:\n                throw 'Unsupported color mode';\n        }\n        return data;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (JpegImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY29ybmVyc3RvbmVqcy9kaWNvbS1pbWFnZS1sb2FkZXIvZGlzdC9lc20vY29kZWNzL2pwZWcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUIsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQyw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNDQUFzQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEMsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL3N1bWl0YXRoYW5pL0Rlc2t0b3AvTmV4dF9EaWNvbS9Gcm9udGVuZC9ub2RlX21vZHVsZXMvQGNvcm5lcnN0b25lanMvZGljb20taW1hZ2UtbG9hZGVyL2Rpc3QvZXNtL2NvZGVjcy9qcGVnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBDb2xvclNwYWNlID0geyBVbmtvd246IDAsIEdyYXlzY2FsZTogMSwgQWRvYmVSR0I6IDIsIFJHQjogMywgQ1lNSzogNCB9O1xudmFyIGRjdFppZ1phZyA9IG5ldyBJbnQzMkFycmF5KFtcbiAgICAwLCAxLCA4LCAxNiwgOSwgMiwgMywgMTAsIDE3LCAyNCwgMzIsIDI1LCAxOCwgMTEsIDQsIDUsIDEyLCAxOSwgMjYsIDMzLCA0MCxcbiAgICA0OCwgNDEsIDM0LCAyNywgMjAsIDEzLCA2LCA3LCAxNCwgMjEsIDI4LCAzNSwgNDIsIDQ5LCA1NiwgNTcsIDUwLCA0MywgMzYsIDI5LFxuICAgIDIyLCAxNSwgMjMsIDMwLCAzNywgNDQsIDUxLCA1OCwgNTksIDUyLCA0NSwgMzgsIDMxLCAzOSwgNDYsIDUzLCA2MCwgNjEsIDU0LFxuICAgIDQ3LCA1NSwgNjIsIDYzLFxuXSk7XG52YXIgZGN0Q29zMSA9IDQwMTc7XG52YXIgZGN0U2luMSA9IDc5OTtcbnZhciBkY3RDb3MzID0gMzQwNjtcbnZhciBkY3RTaW4zID0gMjI3NjtcbnZhciBkY3RDb3M2ID0gMTU2NztcbnZhciBkY3RTaW42ID0gMzc4NDtcbnZhciBkY3RTcXJ0MiA9IDU3OTM7XG52YXIgZGN0U3FydDFkMiA9IDI4OTY7XG5mdW5jdGlvbiBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgdmFsdWVzKSB7XG4gICAgdmFyIGsgPSAwLCBjb2RlID0gW10sIGksIGosIGxlbmd0aCA9IDE2O1xuICAgIHdoaWxlIChsZW5ndGggPiAwICYmICFjb2RlTGVuZ3Roc1tsZW5ndGggLSAxXSlcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgY29kZS5wdXNoKHsgY2hpbGRyZW46IFtdLCBpbmRleDogMCB9KTtcbiAgICB2YXIgcCA9IGNvZGVbMF0sIHE7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2RlTGVuZ3Roc1tpXTsgaisrKSB7XG4gICAgICAgICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgICAgICAgIHAuY2hpbGRyZW5bcC5pbmRleF0gPSB2YWx1ZXNba107XG4gICAgICAgICAgICB3aGlsZSAocC5pbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAuaW5kZXgrKztcbiAgICAgICAgICAgIGNvZGUucHVzaChwKTtcbiAgICAgICAgICAgIHdoaWxlIChjb2RlLmxlbmd0aCA8PSBpKSB7XG4gICAgICAgICAgICAgICAgY29kZS5wdXNoKChxID0geyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pKTtcbiAgICAgICAgICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBwID0gcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSArIDEgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvZGUucHVzaCgocSA9IHsgY2hpbGRyZW46IFtdLCBpbmRleDogMCB9KSk7XG4gICAgICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2RlWzBdLmNoaWxkcmVuO1xufVxuZnVuY3Rpb24gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCByb3csIGNvbCkge1xuICAgIHJldHVybiA2NCAqICgoY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgKyAxKSAqIHJvdyArIGNvbCk7XG59XG5mdW5jdGlvbiBkZWNvZGVTY2FuKGRhdGEsIG9mZnNldCwgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsIHNwZWN0cmFsU3RhcnQsIHNwZWN0cmFsRW5kLCBzdWNjZXNzaXZlUHJldiwgc3VjY2Vzc2l2ZSkge1xuICAgIHZhciBwcmVjaXNpb24gPSBmcmFtZS5wcmVjaXNpb247XG4gICAgdmFyIHNhbXBsZXNQZXJMaW5lID0gZnJhbWUuc2FtcGxlc1BlckxpbmU7XG4gICAgdmFyIHNjYW5MaW5lcyA9IGZyYW1lLnNjYW5MaW5lcztcbiAgICB2YXIgbWN1c1BlckxpbmUgPSBmcmFtZS5tY3VzUGVyTGluZTtcbiAgICB2YXIgcHJvZ3Jlc3NpdmUgPSBmcmFtZS5wcm9ncmVzc2l2ZTtcbiAgICB2YXIgbWF4SCA9IGZyYW1lLm1heEgsIG1heFYgPSBmcmFtZS5tYXhWO1xuICAgIHZhciBzdGFydE9mZnNldCA9IG9mZnNldCwgYml0c0RhdGEgPSAwLCBiaXRzQ291bnQgPSAwO1xuICAgIGZ1bmN0aW9uIHJlYWRCaXQoKSB7XG4gICAgICAgIGlmIChiaXRzQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBiaXRzQ291bnQtLTtcbiAgICAgICAgICAgIHJldHVybiAoYml0c0RhdGEgPj4gYml0c0NvdW50KSAmIDE7XG4gICAgICAgIH1cbiAgICAgICAgYml0c0RhdGEgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgaWYgKGJpdHNEYXRhID09IDB4ZmYpIHtcbiAgICAgICAgICAgIHZhciBuZXh0Qnl0ZSA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgaWYgKG5leHRCeXRlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgbWFya2VyOiAnICsgKChiaXRzRGF0YSA8PCA4KSB8IG5leHRCeXRlKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYml0c0NvdW50ID0gNztcbiAgICAgICAgcmV0dXJuIGJpdHNEYXRhID4+PiA3O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVIdWZmbWFuKHRyZWUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0cmVlO1xuICAgICAgICB2YXIgYml0O1xuICAgICAgICB3aGlsZSAoKGJpdCA9IHJlYWRCaXQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlW2JpdF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCBodWZmbWFuIHNlcXVlbmNlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjZWl2ZShsZW5ndGgpIHtcbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGJpdCA9IHJlYWRCaXQoKTtcbiAgICAgICAgICAgIGlmIChiaXQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbiA9IChuIDw8IDEpIHwgYml0O1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY2VpdmVBbmRFeHRlbmQobGVuZ3RoKSB7XG4gICAgICAgIHZhciBuID0gcmVjZWl2ZShsZW5ndGgpO1xuICAgICAgICBpZiAobiA+PSAxIDw8IChsZW5ndGggLSAxKSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICByZXR1cm4gbiArICgtMSA8PCBsZW5ndGgpICsgMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlQmFzZWxpbmUoY29tcG9uZW50LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgICAgIHZhciBkaWZmID0gdCA9PT0gMCA/IDAgOiByZWNlaXZlQW5kRXh0ZW5kKHQpO1xuICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldF0gPSBjb21wb25lbnQucHJlZCArPSBkaWZmO1xuICAgICAgICB2YXIgayA9IDE7XG4gICAgICAgIHdoaWxlIChrIDwgNjQpIHtcbiAgICAgICAgICAgIHZhciBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgICAgICAgIHZhciBzID0gcnMgJiAxNSwgciA9IHJzID4+IDQ7XG4gICAgICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChyIDwgMTUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGsgKz0gMTY7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrICs9IHI7XG4gICAgICAgICAgICB2YXIgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gPSByZWNlaXZlQW5kRXh0ZW5kKHMpO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZURDRmlyc3QoY29tcG9uZW50LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgICAgIHZhciBkaWZmID0gdCA9PT0gMCA/IDAgOiByZWNlaXZlQW5kRXh0ZW5kKHQpIDw8IHN1Y2Nlc3NpdmU7XG4gICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0XSA9IGNvbXBvbmVudC5wcmVkICs9IGRpZmY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZURDU3VjY2Vzc2l2ZShjb21wb25lbnQsIG9mZnNldCkge1xuICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldF0gfD0gcmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmU7XG4gICAgfVxuICAgIHZhciBlb2JydW4gPSAwO1xuICAgIGZ1bmN0aW9uIGRlY29kZUFDRmlyc3QoY29tcG9uZW50LCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKGVvYnJ1biA+IDApIHtcbiAgICAgICAgICAgIGVvYnJ1bi0tO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrID0gc3BlY3RyYWxTdGFydCwgZSA9IHNwZWN0cmFsRW5kO1xuICAgICAgICB3aGlsZSAoayA8PSBlKSB7XG4gICAgICAgICAgICB2YXIgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICAgICAgICB2YXIgcyA9IHJzICYgMTUsIHIgPSBycyA+PiA0O1xuICAgICAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAociA8IDE1KSB7XG4gICAgICAgICAgICAgICAgICAgIGVvYnJ1biA9IHJlY2VpdmUocikgKyAoMSA8PCByKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrICs9IDE2O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSByO1xuICAgICAgICAgICAgdmFyIHogPSBkY3RaaWdaYWdba107XG4gICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdID0gcmVjZWl2ZUFuZEV4dGVuZChzKSAqICgxIDw8IHN1Y2Nlc3NpdmUpO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzdWNjZXNzaXZlQUNTdGF0ZSA9IDAsIHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZTtcbiAgICBmdW5jdGlvbiBkZWNvZGVBQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGsgPSBzcGVjdHJhbFN0YXJ0LCBlID0gc3BlY3RyYWxFbmQsIHIgPSAwO1xuICAgICAgICB3aGlsZSAoayA8PSBlKSB7XG4gICAgICAgICAgICB2YXIgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3VjY2Vzc2l2ZUFDU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHZhciBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBycyAmIDE1O1xuICAgICAgICAgICAgICAgICAgICByID0gcnMgPj4gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyIDwgMTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlb2JydW4gPSByZWNlaXZlKHIpICsgKDEgPDwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IDE2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzICE9PSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIEFDbiBlbmNvZGluZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPSByZWNlaXZlQW5kRXh0ZW5kKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSByID8gMiA6IDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja0RhdGFbb2Zmc2V0ICsgel0gKz0gcmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAociA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IHN1Y2Nlc3NpdmVBQ1N0YXRlID09IDIgPyAzIDogMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW29mZnNldCArIHpdICs9IHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlIDw8IHN1Y2Nlc3NpdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrRGF0YVtvZmZzZXQgKyB6XSArPSByZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIGVvYnJ1bi0tO1xuICAgICAgICAgICAgaWYgKGVvYnJ1biA9PT0gMClcbiAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlTWN1KGNvbXBvbmVudCwgZGVjb2RlLCBtY3UsIHJvdywgY29sKSB7XG4gICAgICAgIHZhciBtY3VSb3cgPSAobWN1IC8gbWN1c1BlckxpbmUpIHwgMDtcbiAgICAgICAgdmFyIG1jdUNvbCA9IG1jdSAlIG1jdXNQZXJMaW5lO1xuICAgICAgICB2YXIgYmxvY2tSb3cgPSBtY3VSb3cgKiBjb21wb25lbnQudiArIHJvdztcbiAgICAgICAgdmFyIGJsb2NrQ29sID0gbWN1Q29sICogY29tcG9uZW50LmggKyBjb2w7XG4gICAgICAgIHZhciBvZmZzZXQgPSBnZXRCbG9ja0J1ZmZlck9mZnNldChjb21wb25lbnQsIGJsb2NrUm93LCBibG9ja0NvbCk7XG4gICAgICAgIGRlY29kZShjb21wb25lbnQsIG9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZUJsb2NrKGNvbXBvbmVudCwgZGVjb2RlLCBtY3UpIHtcbiAgICAgICAgdmFyIGJsb2NrUm93ID0gKG1jdSAvIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lKSB8IDA7XG4gICAgICAgIHZhciBibG9ja0NvbCA9IG1jdSAlIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCBibG9ja1JvdywgYmxvY2tDb2wpO1xuICAgICAgICBkZWNvZGUoY29tcG9uZW50LCBvZmZzZXQpO1xuICAgIH1cbiAgICB2YXIgY29tcG9uZW50c0xlbmd0aCA9IGNvbXBvbmVudHMubGVuZ3RoO1xuICAgIHZhciBjb21wb25lbnQsIGksIGosIGssIG47XG4gICAgdmFyIGRlY29kZUZuO1xuICAgIGlmIChwcm9ncmVzc2l2ZSkge1xuICAgICAgICBpZiAoc3BlY3RyYWxTdGFydCA9PT0gMClcbiAgICAgICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVEQ0ZpcnN0IDogZGVjb2RlRENTdWNjZXNzaXZlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWNvZGVGbiA9IHN1Y2Nlc3NpdmVQcmV2ID09PSAwID8gZGVjb2RlQUNGaXJzdCA6IGRlY29kZUFDU3VjY2Vzc2l2ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlY29kZUZuID0gZGVjb2RlQmFzZWxpbmU7XG4gICAgfVxuICAgIHZhciBtY3UgPSAwLCBtYXJrZXI7XG4gICAgdmFyIG1jdUV4cGVjdGVkO1xuICAgIGlmIChjb21wb25lbnRzTGVuZ3RoID09IDEpIHtcbiAgICAgICAgbWN1RXhwZWN0ZWQgPSBjb21wb25lbnRzWzBdLmJsb2Nrc1BlckxpbmUgKiBjb21wb25lbnRzWzBdLmJsb2Nrc1BlckNvbHVtbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1jdUV4cGVjdGVkID0gbWN1c1BlckxpbmUgKiBmcmFtZS5tY3VzUGVyQ29sdW1uO1xuICAgIH1cbiAgICBpZiAoIXJlc2V0SW50ZXJ2YWwpIHtcbiAgICAgICAgcmVzZXRJbnRlcnZhbCA9IG1jdUV4cGVjdGVkO1xuICAgIH1cbiAgICB2YXIgaCwgdjtcbiAgICB3aGlsZSAobWN1IDwgbWN1RXhwZWN0ZWQpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5wcmVkID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlb2JydW4gPSAwO1xuICAgICAgICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzWzBdO1xuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IHJlc2V0SW50ZXJ2YWw7IG4rKykge1xuICAgICAgICAgICAgICAgIGRlY29kZUJsb2NrKGNvbXBvbmVudCwgZGVjb2RlRm4sIG1jdSk7XG4gICAgICAgICAgICAgICAgbWN1Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgcmVzZXRJbnRlcnZhbDsgbisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBoID0gY29tcG9uZW50Lmg7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBjb21wb25lbnQudjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHY7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZU1jdShjb21wb25lbnQsIGRlY29kZUZuLCBtY3UsIGosIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1jdSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJpdHNDb3VudCA9IDA7XG4gICAgICAgIG1hcmtlciA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdO1xuICAgICAgICBpZiAobWFya2VyIDw9IDB4ZmYwMCkge1xuICAgICAgICAgICAgdGhyb3cgJ21hcmtlciB3YXMgbm90IGZvdW5kJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyID49IDB4ZmZkMCAmJiBtYXJrZXIgPD0gMHhmZmQ3KSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydE9mZnNldDtcbn1cbmZ1bmN0aW9uIHF1YW50aXplQW5kSW52ZXJzZShjb21wb25lbnQsIGJsb2NrQnVmZmVyT2Zmc2V0LCBwKSB7XG4gICAgdmFyIHF0ID0gY29tcG9uZW50LnF1YW50aXphdGlvblRhYmxlO1xuICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHQ7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgcFtpXSA9IGNvbXBvbmVudC5ibG9ja0RhdGFbYmxvY2tCdWZmZXJPZmZzZXQgKyBpXSAqIHF0W2ldO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICAgIHZhciByb3cgPSA4ICogaTtcbiAgICAgICAgaWYgKHBbMSArIHJvd10gPT09IDAgJiZcbiAgICAgICAgICAgIHBbMiArIHJvd10gPT09IDAgJiZcbiAgICAgICAgICAgIHBbMyArIHJvd10gPT09IDAgJiZcbiAgICAgICAgICAgIHBbNCArIHJvd10gPT09IDAgJiZcbiAgICAgICAgICAgIHBbNSArIHJvd10gPT09IDAgJiZcbiAgICAgICAgICAgIHBbNiArIHJvd10gPT09IDAgJiZcbiAgICAgICAgICAgIHBbNyArIHJvd10gPT09IDApIHtcbiAgICAgICAgICAgIHQgPSAoZGN0U3FydDIgKiBwWzAgKyByb3ddICsgNTEyKSA+PiAxMDtcbiAgICAgICAgICAgIHBbMCArIHJvd10gPSB0O1xuICAgICAgICAgICAgcFsxICsgcm93XSA9IHQ7XG4gICAgICAgICAgICBwWzIgKyByb3ddID0gdDtcbiAgICAgICAgICAgIHBbMyArIHJvd10gPSB0O1xuICAgICAgICAgICAgcFs0ICsgcm93XSA9IHQ7XG4gICAgICAgICAgICBwWzUgKyByb3ddID0gdDtcbiAgICAgICAgICAgIHBbNiArIHJvd10gPSB0O1xuICAgICAgICAgICAgcFs3ICsgcm93XSA9IHQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2MCA9IChkY3RTcXJ0MiAqIHBbMCArIHJvd10gKyAxMjgpID4+IDg7XG4gICAgICAgIHYxID0gKGRjdFNxcnQyICogcFs0ICsgcm93XSArIDEyOCkgPj4gODtcbiAgICAgICAgdjIgPSBwWzIgKyByb3ddO1xuICAgICAgICB2MyA9IHBbNiArIHJvd107XG4gICAgICAgIHY0ID0gKGRjdFNxcnQxZDIgKiAocFsxICsgcm93XSAtIHBbNyArIHJvd10pICsgMTI4KSA+PiA4O1xuICAgICAgICB2NyA9IChkY3RTcXJ0MWQyICogKHBbMSArIHJvd10gKyBwWzcgKyByb3ddKSArIDEyOCkgPj4gODtcbiAgICAgICAgdjUgPSBwWzMgKyByb3ddIDw8IDQ7XG4gICAgICAgIHY2ID0gcFs1ICsgcm93XSA8PCA0O1xuICAgICAgICB0ID0gKHYwIC0gdjEgKyAxKSA+PiAxO1xuICAgICAgICB2MCA9ICh2MCArIHYxICsgMSkgPj4gMTtcbiAgICAgICAgdjEgPSB0O1xuICAgICAgICB0ID0gKHYyICogZGN0U2luNiArIHYzICogZGN0Q29zNiArIDEyOCkgPj4gODtcbiAgICAgICAgdjIgPSAodjIgKiBkY3RDb3M2IC0gdjMgKiBkY3RTaW42ICsgMTI4KSA+PiA4O1xuICAgICAgICB2MyA9IHQ7XG4gICAgICAgIHQgPSAodjQgLSB2NiArIDEpID4+IDE7XG4gICAgICAgIHY0ID0gKHY0ICsgdjYgKyAxKSA+PiAxO1xuICAgICAgICB2NiA9IHQ7XG4gICAgICAgIHQgPSAodjcgKyB2NSArIDEpID4+IDE7XG4gICAgICAgIHY1ID0gKHY3IC0gdjUgKyAxKSA+PiAxO1xuICAgICAgICB2NyA9IHQ7XG4gICAgICAgIHQgPSAodjAgLSB2MyArIDEpID4+IDE7XG4gICAgICAgIHYwID0gKHYwICsgdjMgKyAxKSA+PiAxO1xuICAgICAgICB2MyA9IHQ7XG4gICAgICAgIHQgPSAodjEgLSB2MiArIDEpID4+IDE7XG4gICAgICAgIHYxID0gKHYxICsgdjIgKyAxKSA+PiAxO1xuICAgICAgICB2MiA9IHQ7XG4gICAgICAgIHQgPSAodjQgKiBkY3RTaW4zICsgdjcgKiBkY3RDb3MzICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHY0ID0gKHY0ICogZGN0Q29zMyAtIHY3ICogZGN0U2luMyArIDIwNDgpID4+IDEyO1xuICAgICAgICB2NyA9IHQ7XG4gICAgICAgIHQgPSAodjUgKiBkY3RTaW4xICsgdjYgKiBkY3RDb3MxICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHY1ID0gKHY1ICogZGN0Q29zMSAtIHY2ICogZGN0U2luMSArIDIwNDgpID4+IDEyO1xuICAgICAgICB2NiA9IHQ7XG4gICAgICAgIHBbMCArIHJvd10gPSB2MCArIHY3O1xuICAgICAgICBwWzcgKyByb3ddID0gdjAgLSB2NztcbiAgICAgICAgcFsxICsgcm93XSA9IHYxICsgdjY7XG4gICAgICAgIHBbNiArIHJvd10gPSB2MSAtIHY2O1xuICAgICAgICBwWzIgKyByb3ddID0gdjIgKyB2NTtcbiAgICAgICAgcFs1ICsgcm93XSA9IHYyIC0gdjU7XG4gICAgICAgIHBbMyArIHJvd10gPSB2MyArIHY0O1xuICAgICAgICBwWzQgKyByb3ddID0gdjMgLSB2NDtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICB2YXIgY29sID0gaTtcbiAgICAgICAgaWYgKHBbMSAqIDggKyBjb2xdID09PSAwICYmXG4gICAgICAgICAgICBwWzIgKiA4ICsgY29sXSA9PT0gMCAmJlxuICAgICAgICAgICAgcFszICogOCArIGNvbF0gPT09IDAgJiZcbiAgICAgICAgICAgIHBbNCAqIDggKyBjb2xdID09PSAwICYmXG4gICAgICAgICAgICBwWzUgKiA4ICsgY29sXSA9PT0gMCAmJlxuICAgICAgICAgICAgcFs2ICogOCArIGNvbF0gPT09IDAgJiZcbiAgICAgICAgICAgIHBbNyAqIDggKyBjb2xdID09PSAwKSB7XG4gICAgICAgICAgICB0ID0gKGRjdFNxcnQyICogcFtpICsgMF0gKyA4MTkyKSA+PiAxNDtcbiAgICAgICAgICAgIHBbMCAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgICAgIHBbMSAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgICAgIHBbMiAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgICAgIHBbMyAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgICAgIHBbNCAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgICAgIHBbNSAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgICAgIHBbNiAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgICAgIHBbNyAqIDggKyBjb2xdID0gdDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHYwID0gKGRjdFNxcnQyICogcFswICogOCArIGNvbF0gKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgdjEgPSAoZGN0U3FydDIgKiBwWzQgKiA4ICsgY29sXSArIDIwNDgpID4+IDEyO1xuICAgICAgICB2MiA9IHBbMiAqIDggKyBjb2xdO1xuICAgICAgICB2MyA9IHBbNiAqIDggKyBjb2xdO1xuICAgICAgICB2NCA9IChkY3RTcXJ0MWQyICogKHBbMSAqIDggKyBjb2xdIC0gcFs3ICogOCArIGNvbF0pICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHY3ID0gKGRjdFNxcnQxZDIgKiAocFsxICogOCArIGNvbF0gKyBwWzcgKiA4ICsgY29sXSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgdjUgPSBwWzMgKiA4ICsgY29sXTtcbiAgICAgICAgdjYgPSBwWzUgKiA4ICsgY29sXTtcbiAgICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTtcbiAgICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XG4gICAgICAgIHYxID0gdDtcbiAgICAgICAgdCA9ICh2MiAqIGRjdFNpbjYgKyB2MyAqIGRjdENvczYgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgdjIgPSAodjIgKiBkY3RDb3M2IC0gdjMgKiBkY3RTaW42ICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHYzID0gdDtcbiAgICAgICAgdCA9ICh2NCAtIHY2ICsgMSkgPj4gMTtcbiAgICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XG4gICAgICAgIHY2ID0gdDtcbiAgICAgICAgdCA9ICh2NyArIHY1ICsgMSkgPj4gMTtcbiAgICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XG4gICAgICAgIHY3ID0gdDtcbiAgICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTtcbiAgICAgICAgdjAgPSAodjAgKyB2MyArIDEpID4+IDE7XG4gICAgICAgIHYzID0gdDtcbiAgICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTtcbiAgICAgICAgdjEgPSAodjEgKyB2MiArIDEpID4+IDE7XG4gICAgICAgIHYyID0gdDtcbiAgICAgICAgdCA9ICh2NCAqIGRjdFNpbjMgKyB2NyAqIGRjdENvczMgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgdjQgPSAodjQgKiBkY3RDb3MzIC0gdjcgKiBkY3RTaW4zICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHY3ID0gdDtcbiAgICAgICAgdCA9ICh2NSAqIGRjdFNpbjEgKyB2NiAqIGRjdENvczEgKyAyMDQ4KSA+PiAxMjtcbiAgICAgICAgdjUgPSAodjUgKiBkY3RDb3MxIC0gdjYgKiBkY3RTaW4xICsgMjA0OCkgPj4gMTI7XG4gICAgICAgIHY2ID0gdDtcbiAgICAgICAgcFswICogOCArIGNvbF0gPSB2MCArIHY3O1xuICAgICAgICBwWzcgKiA4ICsgY29sXSA9IHYwIC0gdjc7XG4gICAgICAgIHBbMSAqIDggKyBjb2xdID0gdjEgKyB2NjtcbiAgICAgICAgcFs2ICogOCArIGNvbF0gPSB2MSAtIHY2O1xuICAgICAgICBwWzIgKiA4ICsgY29sXSA9IHYyICsgdjU7XG4gICAgICAgIHBbNSAqIDggKyBjb2xdID0gdjIgLSB2NTtcbiAgICAgICAgcFszICogOCArIGNvbF0gPSB2MyArIHY0O1xuICAgICAgICBwWzQgKiA4ICsgY29sXSA9IHYzIC0gdjQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJsb2NrQnVmZmVyT2Zmc2V0ICsgaTtcbiAgICAgICAgdmFyIHEgPSBwW2ldO1xuICAgICAgICBxID1cbiAgICAgICAgICAgIHEgPD0gLTIwNTYgLyBjb21wb25lbnQuYml0Q29udmVyc2lvblxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogcSA+PSAyMDI0IC8gY29tcG9uZW50LmJpdENvbnZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgPyAyNTUgLyBjb21wb25lbnQuYml0Q29udmVyc2lvblxuICAgICAgICAgICAgICAgICAgICA6IChxICsgMjA1NiAvIGNvbXBvbmVudC5iaXRDb252ZXJzaW9uKSA+PiA0O1xuICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhW2luZGV4XSA9IHE7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRDb21wb25lbnREYXRhKGZyYW1lLCBjb21wb25lbnQpIHtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB2YXIgYmxvY2tzUGVyTGluZSA9IGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lO1xuICAgIHZhciBibG9ja3NQZXJDb2x1bW4gPSBjb21wb25lbnQuYmxvY2tzUGVyQ29sdW1uO1xuICAgIHZhciBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcbiAgICB2YXIgY29tcHV0YXRpb25CdWZmZXIgPSBuZXcgSW50MzJBcnJheSg2NCk7XG4gICAgdmFyIGksIGosIGxsID0gMDtcbiAgICBmb3IgKHZhciBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XG4gICAgICAgIGZvciAodmFyIGJsb2NrQ29sID0gMDsgYmxvY2tDb2wgPCBibG9ja3NQZXJMaW5lOyBibG9ja0NvbCsrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCBibG9ja1JvdywgYmxvY2tDb2wpO1xuICAgICAgICAgICAgcXVhbnRpemVBbmRJbnZlcnNlKGNvbXBvbmVudCwgb2Zmc2V0LCBjb21wdXRhdGlvbkJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudC5ibG9ja0RhdGE7XG59XG5mdW5jdGlvbiBjbGFtcFRvVWludDgoYSkge1xuICAgIHJldHVybiBhIDw9IDAgPyAwIDogYSA+PSAyNTUgPyAyNTUgOiBhIHwgMDtcbn1cbmNsYXNzIEpwZWdJbWFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICBsb2FkKHBhdGgpIHtcbiAgICAgICAgdmFyIGhhbmRsZURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ubG9hZClcbiAgICAgICAgICAgICAgICB0aGlzLm9ubG9hZCgpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoJ2RhdGE6JykgPiAtMSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHBhdGguaW5kZXhPZignYmFzZTY0LCcpICsgNztcbiAgICAgICAgICAgIHZhciBkYXRhID0gYXRvYihwYXRoLnN1YnN0cmluZyhvZmZzZXQpKTtcbiAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZURhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGhhbmRsZURhdGEoZGF0YSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZShkYXRhKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRVaW50MTYoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlYWREYXRhQmxvY2soKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcmVwYXJlQ29tcG9uZW50cyhmcmFtZSkge1xuICAgICAgICAgICAgdmFyIG1jdXNQZXJMaW5lID0gTWF0aC5jZWlsKGZyYW1lLnNhbXBsZXNQZXJMaW5lIC8gOCAvIGZyYW1lLm1heEgpO1xuICAgICAgICAgICAgdmFyIG1jdXNQZXJDb2x1bW4gPSBNYXRoLmNlaWwoZnJhbWUuc2NhbkxpbmVzIC8gOCAvIGZyYW1lLm1heFYpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZS5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tzUGVyTGluZSA9IE1hdGguY2VpbCgoTWF0aC5jZWlsKGZyYW1lLnNhbXBsZXNQZXJMaW5lIC8gOCkgKiBjb21wb25lbnQuaCkgLyBmcmFtZS5tYXhIKTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tzUGVyQ29sdW1uID0gTWF0aC5jZWlsKChNYXRoLmNlaWwoZnJhbWUuc2NhbkxpbmVzIC8gOCkgKiBjb21wb25lbnQudikgLyBmcmFtZS5tYXhWKTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tzUGVyTGluZUZvck1jdSA9IG1jdXNQZXJMaW5lICogY29tcG9uZW50Lmg7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2Nrc1BlckNvbHVtbkZvck1jdSA9IG1jdXNQZXJDb2x1bW4gKiBjb21wb25lbnQudjtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tzQnVmZmVyU2l6ZSA9IDY0ICogYmxvY2tzUGVyQ29sdW1uRm9yTWN1ICogKGJsb2Nrc1BlckxpbmVGb3JNY3UgKyAxKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuYmxvY2tEYXRhID0gbmV3IEludDE2QXJyYXkoYmxvY2tzQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW4gPSBibG9ja3NQZXJDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZS5tY3VzUGVyTGluZSA9IG1jdXNQZXJMaW5lO1xuICAgICAgICAgICAgZnJhbWUubWN1c1BlckNvbHVtbiA9IG1jdXNQZXJDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB2YXIgamZpZiA9IG51bGw7XG4gICAgICAgIHZhciBhZG9iZSA9IG51bGw7XG4gICAgICAgIHZhciBwaXhlbHMgPSBudWxsO1xuICAgICAgICB2YXIgZnJhbWUsIHJlc2V0SW50ZXJ2YWw7XG4gICAgICAgIHZhciBxdWFudGl6YXRpb25UYWJsZXMgPSBbXTtcbiAgICAgICAgdmFyIGh1ZmZtYW5UYWJsZXNBQyA9IFtdLCBodWZmbWFuVGFibGVzREMgPSBbXTtcbiAgICAgICAgdmFyIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XG4gICAgICAgIGlmIChmaWxlTWFya2VyICE9IDB4ZmZkOCkge1xuICAgICAgICAgICAgdGhyb3cgJ1NPSSBub3QgZm91bmQnO1xuICAgICAgICB9XG4gICAgICAgIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XG4gICAgICAgIHdoaWxlIChmaWxlTWFya2VyICE9IDB4ZmZkOSkge1xuICAgICAgICAgICAgdmFyIGksIGosIGw7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpbGVNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlMDpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlMTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlMjpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlMzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlNDpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlNTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlNjpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlNzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlODpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlOTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlYTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlYjpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlYzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlZDpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlZTpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZlZjpcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZmZTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwcERhdGEgPSByZWFkRGF0YUJsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweGZmZTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcHBEYXRhWzBdID09PSAweDRhICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwRGF0YVsxXSA9PT0gMHg0NiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcERhdGFbMl0gPT09IDB4NDkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBEYXRhWzNdID09PSAweDQ2ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwRGF0YVs0XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpmaWYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHsgbWFqb3I6IGFwcERhdGFbNV0sIG1pbm9yOiBhcHBEYXRhWzZdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNpdHlVbml0czogYXBwRGF0YVs3XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeERlbnNpdHk6IChhcHBEYXRhWzhdIDw8IDgpIHwgYXBwRGF0YVs5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeURlbnNpdHk6IChhcHBEYXRhWzEwXSA8PCA4KSB8IGFwcERhdGFbMTFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYldpZHRoOiBhcHBEYXRhWzEyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJIZWlnaHQ6IGFwcERhdGFbMTNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYkRhdGE6IGFwcERhdGEuc3ViYXJyYXkoMTQsIDE0ICsgMyAqIGFwcERhdGFbMTJdICogYXBwRGF0YVsxM10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVNYXJrZXIgPT09IDB4ZmZlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFwcERhdGFbMF0gPT09IDB4NDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBEYXRhWzFdID09PSAweDY0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwRGF0YVsyXSA9PT0gMHg2ZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcERhdGFbM10gPT09IDB4NjIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBEYXRhWzRdID09PSAweDY1ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwRGF0YVs1XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkb2JlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBhcHBEYXRhWzZdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFnczA6IChhcHBEYXRhWzddIDw8IDgpIHwgYXBwRGF0YVs4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MxOiAoYXBwRGF0YVs5XSA8PCA4KSB8IGFwcERhdGFbMTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Db2RlOiBhcHBEYXRhWzExXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhmZmRiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVhbnRpemF0aW9uVGFibGVzRW5kID0gcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoICsgb2Zmc2V0IC0gMjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHF1YW50aXphdGlvblRhYmxlc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1YW50aXphdGlvblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlRGF0YSA9IG5ldyBJbnQzMkFycmF5KDY0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6ID0gZGN0WmlnWmFnW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZURhdGFbel0gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6eiA9IGRjdFppZ1phZ1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVEYXRhW3p6XSA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0RRVDogaW52YWxpZCB0YWJsZSBzcGVjJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXphdGlvblRhYmxlc1txdWFudGl6YXRpb25UYWJsZVNwZWMgJiAxNV0gPSB0YWJsZURhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweGZmYzA6XG4gICAgICAgICAgICAgICAgY2FzZSAweGZmYzE6XG4gICAgICAgICAgICAgICAgY2FzZSAweGZmYzI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ09ubHkgc2luZ2xlIGZyYW1lIEpQRUdzIHN1cHBvcnRlZCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5leHRlbmRlZCA9IGZpbGVNYXJrZXIgPT09IDB4ZmZjMTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUucHJvZ3Jlc3NpdmUgPSBmaWxlTWFya2VyID09PSAweGZmYzI7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnByZWNpc2lvbiA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5zY2FuTGluZXMgPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnNhbXBsZXNQZXJMaW5lID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5jb21wb25lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudElkcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50c0NvdW50ID0gZGF0YVtvZmZzZXQrK10sIGNvbXBvbmVudElkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4SCA9IDAsIG1heFYgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudElkID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBkYXRhW29mZnNldCArIDFdID4+IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGRhdGFbb2Zmc2V0ICsgMV0gJiAxNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhIIDwgaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhIID0gaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhWIDwgdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhWID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxSWQgPSBkYXRhW29mZnNldCArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IGZyYW1lLmNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2OiB2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YW50aXphdGlvblRhYmxlOiBxdWFudGl6YXRpb25UYWJsZXNbcUlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFudGl6YXRpb25UYWJsZUlkOiBxSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0Q29udmVyc2lvbjogMjU1IC8gKCgxIDw8IGZyYW1lLnByZWNpc2lvbikgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuY29tcG9uZW50SWRzW2NvbXBvbmVudElkXSA9IGwgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJhbWUubWF4SCA9IG1heEg7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLm1heFYgPSBtYXhWO1xuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlQ29tcG9uZW50cyhmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHhmZmM0OlxuICAgICAgICAgICAgICAgICAgICB2YXIgaHVmZm1hbkxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMjsgaSA8IGh1ZmZtYW5MZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHVmZm1hblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVMZW5ndGhzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVMZW5ndGhTdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDE2OyBqKyssIG9mZnNldCsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhTdW0gKz0gY29kZUxlbmd0aHNbal0gPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHVmZm1hblZhbHVlcyA9IG5ldyBVaW50OEFycmF5KGNvZGVMZW5ndGhTdW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvZGVMZW5ndGhTdW07IGorKywgb2Zmc2V0KyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHVmZm1hblZhbHVlc1tqXSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTcgKyBjb2RlTGVuZ3RoU3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGh1ZmZtYW5UYWJsZVNwZWMgPj4gNCA9PT0gMCA/IGh1ZmZtYW5UYWJsZXNEQyA6IGh1ZmZtYW5UYWJsZXNBQylbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9IGJ1aWxkSHVmZm1hblRhYmxlKGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZkZDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICAgICAgICByZXNldEludGVydmFsID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZkYTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYW5MZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvcnNDb3VudCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdLCBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3RvcnNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50SW5kZXggPSBmcmFtZS5jb21wb25lbnRJZHNbZGF0YVtvZmZzZXQrK11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tjb21wb25lbnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlREMgPSBodWZmbWFuVGFibGVzRENbdGFibGVTcGVjID4+IDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDID0gaHVmZm1hblRhYmxlc0FDW3RhYmxlU3BlYyAmIDE1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGVjdHJhbFN0YXJ0ID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGVjdHJhbEVuZCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZCA9IGRlY29kZVNjYW4oZGF0YSwgb2Zmc2V0LCBmcmFtZSwgY29tcG9uZW50cywgcmVzZXRJbnRlcnZhbCwgc3BlY3RyYWxTdGFydCwgc3BlY3RyYWxFbmQsIHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uID4+IDQsIHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uICYgMTUpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcHJvY2Vzc2VkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmZmZjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSAhPT0gMHhmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0IC0gM10gPT0gMHhmZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgLSAyXSA+PSAweGMwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCAtIDJdIDw9IDB4ZmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3Vua25vd24gSlBFRyBtYXJrZXIgJyArIGZpbGVNYXJrZXIudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZHRoID0gZnJhbWUuc2FtcGxlc1BlckxpbmU7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZnJhbWUuc2NhbkxpbmVzO1xuICAgICAgICB0aGlzLmpmaWYgPSBqZmlmO1xuICAgICAgICB0aGlzLmFkb2JlID0gYWRvYmU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBzd2l0Y2ggKGZyYW1lLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvcnNwYWNlID0gQ29sb3JTcGFjZS5HcmF5c2NhbGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWRvYmUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3JzcGFjZSA9IENvbG9yU3BhY2UuQWRvYmVSR0I7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yc3BhY2UgPSBDb2xvclNwYWNlLlJHQjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yc3BhY2UgPSBDb2xvclNwYWNlLkNZTUs7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JzcGFjZSA9IENvbG9yU3BhY2UuVW5rbm93bjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGUgJiZcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGVJZCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGUgPVxuICAgICAgICAgICAgICAgICAgICBxdWFudGl6YXRpb25UYWJsZXNbY29tcG9uZW50LnF1YW50aXphdGlvblRhYmxlSWRdO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG91dHB1dDogYnVpbGRDb21wb25lbnREYXRhKGZyYW1lLCBjb21wb25lbnQpLFxuICAgICAgICAgICAgICAgIHNjYWxlWDogY29tcG9uZW50LmggLyBmcmFtZS5tYXhILFxuICAgICAgICAgICAgICAgIHNjYWxlWTogY29tcG9uZW50LnYgLyBmcmFtZS5tYXhWLFxuICAgICAgICAgICAgICAgIGJsb2Nrc1BlckxpbmU6IGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lLFxuICAgICAgICAgICAgICAgIGJsb2Nrc1BlckNvbHVtbjogY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbixcbiAgICAgICAgICAgICAgICBiaXRDb252ZXJzaW9uOiBjb21wb25lbnQuYml0Q29udmVyc2lvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldERhdGExNih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIGNvbG9yIG1vZGUnO1xuICAgICAgICB2YXIgc2NhbGVYID0gdGhpcy53aWR0aCAvIHdpZHRoLCBzY2FsZVkgPSB0aGlzLmhlaWdodCAvIGhlaWdodDtcbiAgICAgICAgdmFyIGNvbXBvbmVudCwgY29tcG9uZW50U2NhbGVYLCBjb21wb25lbnRTY2FsZVk7XG4gICAgICAgIHZhciB4LCB5LCBpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG51bUNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgZGF0YUxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogbnVtQ29tcG9uZW50cztcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDE2QXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICAgIHZhciBjb21wb25lbnRMaW5lO1xuICAgICAgICB2YXIgbGluZURhdGEgPSBuZXcgVWludDE2QXJyYXkoKHRoaXMuY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lIDw8IDMpICpcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW4gKlxuICAgICAgICAgICAgOCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1Db21wb25lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBibG9ja3NQZXJMaW5lID0gY29tcG9uZW50LmJsb2Nrc1BlckxpbmU7XG4gICAgICAgICAgICB2YXIgYmxvY2tzUGVyQ29sdW1uID0gY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbjtcbiAgICAgICAgICAgIHZhciBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcbiAgICAgICAgICAgIHZhciBqLCBrLCBsbCA9IDA7XG4gICAgICAgICAgICB2YXIgbGluZU9mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYW5MaW5lID0gYmxvY2tSb3cgPDwgMztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBibG9ja0NvbCA9IDA7IGJsb2NrQ29sIDwgYmxvY2tzUGVyTGluZTsgYmxvY2tDb2wrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyT2Zmc2V0ID0gZ2V0QmxvY2tCdWZmZXJPZmZzZXQoY29tcG9uZW50LCBibG9ja1JvdywgYmxvY2tDb2wpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMCwgc2FtcGxlID0gYmxvY2tDb2wgPDwgMztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSAoc2NhbkxpbmUgKyBqKSAqIHNhbXBsZXNQZXJMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVEYXRhW2xpbmVPZmZzZXQgKyBzYW1wbGUgKyBrXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5vdXRwdXRbYnVmZmVyT2Zmc2V0ICsgb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50U2NhbGVYID0gY29tcG9uZW50LnNjYWxlWCAqIHNjYWxlWDtcbiAgICAgICAgICAgIGNvbXBvbmVudFNjYWxlWSA9IGNvbXBvbmVudC5zY2FsZVkgKiBzY2FsZVk7XG4gICAgICAgICAgICBvZmZzZXQgPSBpO1xuICAgICAgICAgICAgdmFyIGN4LCBjeTtcbiAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGN5ID0gMCB8ICh5ICogY29tcG9uZW50U2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgICAgY3ggPSAwIHwgKHggKiBjb21wb25lbnRTY2FsZVgpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGN5ICogc2FtcGxlc1BlckxpbmUgKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gbGluZURhdGFbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gbnVtQ29tcG9uZW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGdldERhdGEod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgc2NhbGVYID0gdGhpcy53aWR0aCAvIHdpZHRoLCBzY2FsZVkgPSB0aGlzLmhlaWdodCAvIGhlaWdodDtcbiAgICAgICAgdmFyIGNvbXBvbmVudCwgY29tcG9uZW50U2NhbGVYLCBjb21wb25lbnRTY2FsZVk7XG4gICAgICAgIHZhciB4LCB5LCBpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIFksIENiLCBDciwgSywgQywgTSwgWWUsIFIsIEcsIEI7XG4gICAgICAgIHZhciBjb2xvclRyYW5zZm9ybTtcbiAgICAgICAgdmFyIG51bUNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgZGF0YUxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogbnVtQ29tcG9uZW50cztcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudExpbmU7XG4gICAgICAgIHZhciBsaW5lRGF0YSA9IG5ldyBVaW50OEFycmF5KCh0aGlzLmNvbXBvbmVudHNbMF0uYmxvY2tzUGVyTGluZSA8PCAzKSAqXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbMF0uYmxvY2tzUGVyQ29sdW1uICpcbiAgICAgICAgICAgIDgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ29tcG9uZW50czsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICB2YXIgYmxvY2tzUGVyTGluZSA9IGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lO1xuICAgICAgICAgICAgdmFyIGJsb2Nrc1BlckNvbHVtbiA9IGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW47XG4gICAgICAgICAgICB2YXIgc2FtcGxlc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lIDw8IDM7XG4gICAgICAgICAgICB2YXIgaiwgaywgbGwgPSAwO1xuICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgYmxvY2tSb3cgPSAwOyBibG9ja1JvdyA8IGJsb2Nrc1BlckNvbHVtbjsgYmxvY2tSb3crKykge1xuICAgICAgICAgICAgICAgIHZhciBzY2FuTGluZSA9IGJsb2NrUm93IDw8IDM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYmxvY2tDb2wgPSAwOyBibG9ja0NvbCA8IGJsb2Nrc1BlckxpbmU7IGJsb2NrQ29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlck9mZnNldCA9IGdldEJsb2NrQnVmZmVyT2Zmc2V0KGNvbXBvbmVudCwgYmxvY2tSb3csIGJsb2NrQ29sKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDAsIHNhbXBsZSA9IGJsb2NrQ29sIDw8IDM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gKHNjYW5MaW5lICsgaikgKiBzYW1wbGVzUGVyTGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lRGF0YVtsaW5lT2Zmc2V0ICsgc2FtcGxlICsga10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQub3V0cHV0W2J1ZmZlck9mZnNldCArIG9mZnNldCsrXSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuYml0Q29udmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudFNjYWxlWCA9IGNvbXBvbmVudC5zY2FsZVggKiBzY2FsZVg7XG4gICAgICAgICAgICBjb21wb25lbnRTY2FsZVkgPSBjb21wb25lbnQuc2NhbGVZICogc2NhbGVZO1xuICAgICAgICAgICAgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgIHZhciBjeCwgY3k7XG4gICAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBjeSA9IDAgfCAoeSAqIGNvbXBvbmVudFNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgIGN4ID0gMCB8ICh4ICogY29tcG9uZW50U2NhbGVYKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjeSAqIHNhbXBsZXNQZXJMaW5lICsgY3g7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGxpbmVEYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IG51bUNvbXBvbmVudHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobnVtQ29tcG9uZW50cykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hZG9iZSAmJiB0aGlzLmFkb2JlLnRyYW5zZm9ybUNvZGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb2xvclRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gISF0aGlzLmNvbG9yVHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvclRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSArPSBudW1Db21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBZID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIENiID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBDciA9IGRhdGFbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgUiA9IGNsYW1wVG9VaW50OChZIC0gMTc5LjQ1NiArIDEuNDAyICogQ3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgRyA9IGNsYW1wVG9VaW50OChZICsgMTM1LjQ1OSAtIDAuMzQ0ICogQ2IgLSAwLjcxNCAqIENyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEIgPSBjbGFtcFRvVWludDgoWSAtIDIyNi44MTYgKyAxLjc3MiAqIENiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV0gPSBSO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBHO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBCO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hZG9iZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIGNvbG9yIG1vZGUgKDQgY29tcG9uZW50cyknO1xuICAgICAgICAgICAgICAgIGNvbG9yVHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWRvYmUgJiYgdGhpcy5hZG9iZS50cmFuc2Zvcm1Db2RlKVxuICAgICAgICAgICAgICAgICAgICBjb2xvclRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuY29sb3JUcmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICBjb2xvclRyYW5zZm9ybSA9ICEhdGhpcy5jb2xvclRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkgKz0gbnVtQ29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgWSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBDYiA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3IgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEMgPSBjbGFtcFRvVWludDgoNDM0LjQ1NiAtIFkgLSAxLjQwMiAqIENyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE0gPSBjbGFtcFRvVWludDgoMTE5LjU0MSAtIFkgKyAwLjM0NCAqIENiICsgMC43MTQgKiBDcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBZID0gY2xhbXBUb1VpbnQ4KDQ4MS44MTYgLSBZIC0gMS43NzIgKiBDYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ldID0gQztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSArIDJdID0gWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1Vuc3VwcG9ydGVkIGNvbG9yIG1vZGUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEpwZWdJbWFnZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@cornerstonejs/dicom-image-loader/dist/esm/codecs/jpeg.js\n"));

/***/ })

}]);