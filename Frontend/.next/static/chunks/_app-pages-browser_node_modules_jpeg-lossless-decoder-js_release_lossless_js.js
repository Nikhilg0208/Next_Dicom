"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_jpeg-lossless-decoder-js_release_lossless_js"],{

/***/ "(app-pages-browser)/./node_modules/jpeg-lossless-decoder-js/release/lossless.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jpeg-lossless-decoder-js/release/lossless.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ComponentSpec: () => (/* binding */ ComponentSpec),\n/* harmony export */   DataStream: () => (/* binding */ DataStream),\n/* harmony export */   Decoder: () => (/* binding */ Decoder),\n/* harmony export */   FrameHeader: () => (/* binding */ FrameHeader),\n/* harmony export */   HuffmanTable: () => (/* binding */ HuffmanTable),\n/* harmony export */   QuantizationTable: () => (/* binding */ QuantizationTable),\n/* harmony export */   ScanComponent: () => (/* binding */ ScanComponent),\n/* harmony export */   ScanHeader: () => (/* binding */ ScanHeader),\n/* harmony export */   Utils: () => (/* binding */ utils_exports)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/component-spec.ts\nvar ComponentSpec = {\n  hSamp: 0,\n  quantTableSel: 0,\n  vSamp: 0\n};\n\n// src/data-stream.ts\nvar DataStream = class {\n  buffer;\n  index;\n  constructor(data, offset, length) {\n    this.buffer = new Uint8Array(data, offset, length);\n    this.index = 0;\n  }\n  get16() {\n    const value = (this.buffer[this.index] << 8) + this.buffer[this.index + 1];\n    this.index += 2;\n    return value;\n  }\n  get8() {\n    const value = this.buffer[this.index];\n    this.index += 1;\n    return value;\n  }\n};\n\n// src/frame-header.ts\nvar FrameHeader = class {\n  dimX = 0;\n  dimY = 0;\n  numComp = 0;\n  precision = 0;\n  components = [];\n  read(data) {\n    let count = 0;\n    let temp;\n    const length = data.get16();\n    count += 2;\n    this.precision = data.get8();\n    count += 1;\n    this.dimY = data.get16();\n    count += 2;\n    this.dimX = data.get16();\n    count += 2;\n    this.numComp = data.get8();\n    count += 1;\n    for (let i = 1; i <= this.numComp; i += 1) {\n      if (count > length) {\n        throw new Error(\"ERROR: frame format error\");\n      }\n      const c = data.get8();\n      count += 1;\n      if (count >= length) {\n        throw new Error(\"ERROR: frame format error [c>=Lf]\");\n      }\n      temp = data.get8();\n      count += 1;\n      if (!this.components[c]) {\n        this.components[c] = { ...ComponentSpec };\n      }\n      this.components[c].hSamp = temp >> 4;\n      this.components[c].vSamp = temp & 15;\n      this.components[c].quantTableSel = data.get8();\n      count += 1;\n    }\n    if (count !== length) {\n      throw new Error(\"ERROR: frame format error [Lf!=count]\");\n    }\n    return 1;\n  }\n};\n\n// src/utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  crc32: () => crc32,\n  crcTable: () => crcTable,\n  createArray: () => createArray,\n  makeCRCTable: () => makeCRCTable\n});\nvar createArray = (...dimensions) => {\n  if (dimensions.length > 1) {\n    const dim = dimensions[0];\n    const rest = dimensions.slice(1);\n    const newArray = [];\n    for (let i = 0; i < dim; i++) {\n      newArray[i] = createArray(...rest);\n    }\n    return newArray;\n  } else {\n    return Array(dimensions[0]).fill(void 0);\n  }\n};\nvar makeCRCTable = function() {\n  let c;\n  const crcTable2 = [];\n  for (let n = 0; n < 256; n++) {\n    c = n;\n    for (let k = 0; k < 8; k++) {\n      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;\n    }\n    crcTable2[n] = c;\n  }\n  return crcTable2;\n};\nvar crcTable = makeCRCTable();\nvar crc32 = function(buffer) {\n  const uint8view = new Uint8Array(buffer);\n  let crc = 0 ^ -1;\n  for (let i = 0; i < uint8view.length; i++) {\n    crc = crc >>> 8 ^ crcTable[(crc ^ uint8view[i]) & 255];\n  }\n  return (crc ^ -1) >>> 0;\n};\n\n// src/huffman-table.ts\nvar HuffmanTable = class _HuffmanTable {\n  static MSB = 2147483648;\n  l;\n  th;\n  v;\n  tc;\n  constructor() {\n    this.l = createArray(4, 2, 16);\n    this.th = [0, 0, 0, 0];\n    this.v = createArray(4, 2, 16, 200);\n    this.tc = [\n      [0, 0],\n      [0, 0],\n      [0, 0],\n      [0, 0]\n    ];\n  }\n  read(data, HuffTab) {\n    let count = 0;\n    let temp;\n    let t;\n    let c;\n    let i;\n    let j;\n    const length = data.get16();\n    count += 2;\n    while (count < length) {\n      temp = data.get8();\n      count += 1;\n      t = temp & 15;\n      if (t > 3) {\n        throw new Error(\"ERROR: Huffman table ID > 3\");\n      }\n      c = temp >> 4;\n      if (c > 2) {\n        throw new Error(\"ERROR: Huffman table [Table class > 2 ]\");\n      }\n      this.th[t] = 1;\n      this.tc[t][c] = 1;\n      for (i = 0; i < 16; i += 1) {\n        this.l[t][c][i] = data.get8();\n        count += 1;\n      }\n      for (i = 0; i < 16; i += 1) {\n        for (j = 0; j < this.l[t][c][i]; j += 1) {\n          if (count > length) {\n            throw new Error(\"ERROR: Huffman table format error [count>Lh]\");\n          }\n          this.v[t][c][i][j] = data.get8();\n          count += 1;\n        }\n      }\n    }\n    if (count !== length) {\n      throw new Error(\"ERROR: Huffman table format error [count!=Lf]\");\n    }\n    for (i = 0; i < 4; i += 1) {\n      for (j = 0; j < 2; j += 1) {\n        if (this.tc[i][j] !== 0) {\n          this.buildHuffTable(HuffTab[i][j], this.l[i][j], this.v[i][j]);\n        }\n      }\n    }\n    return 1;\n  }\n  //\tBuild_HuffTab()\n  //\tParameter:  t       table ID\n  //\t            c       table class ( 0 for DC, 1 for AC )\n  //\t            L[i]    # of codewords which length is i\n  //\t            V[i][j] Huffman Value (length=i)\n  //\tEffect:\n  //\t    build up HuffTab[t][c] using L and V.\n  buildHuffTable(tab, L, V) {\n    let currentTable, k, i, j, n;\n    const temp = 256;\n    k = 0;\n    for (i = 0; i < 8; i += 1) {\n      for (j = 0; j < L[i]; j += 1) {\n        for (n = 0; n < temp >> i + 1; n += 1) {\n          tab[k] = V[i][j] | i + 1 << 8;\n          k += 1;\n        }\n      }\n    }\n    for (i = 1; k < 256; i += 1, k += 1) {\n      tab[k] = i | _HuffmanTable.MSB;\n    }\n    currentTable = 1;\n    k = 0;\n    for (i = 8; i < 16; i += 1) {\n      for (j = 0; j < L[i]; j += 1) {\n        for (n = 0; n < temp >> i - 7; n += 1) {\n          tab[currentTable * 256 + k] = V[i][j] | i + 1 << 8;\n          k += 1;\n        }\n        if (k >= 256) {\n          if (k > 256) {\n            throw new Error(\"ERROR: Huffman table error(1)!\");\n          }\n          k = 0;\n          currentTable += 1;\n        }\n      }\n    }\n  }\n};\n\n// src/quantization-table.ts\nvar QuantizationTable = class _QuantizationTable {\n  precision = [];\n  // Quantization precision 8 or 16\n  tq = [0, 0, 0, 0];\n  // 1: this table is presented\n  quantTables = createArray(4, 64);\n  // Tables\n  static enhanceQuantizationTable = function(qtab, table) {\n    for (let i = 0; i < 8; i += 1) {\n      qtab[table[0 * 8 + i]] *= 90;\n      qtab[table[4 * 8 + i]] *= 90;\n      qtab[table[2 * 8 + i]] *= 118;\n      qtab[table[6 * 8 + i]] *= 49;\n      qtab[table[5 * 8 + i]] *= 71;\n      qtab[table[1 * 8 + i]] *= 126;\n      qtab[table[7 * 8 + i]] *= 25;\n      qtab[table[3 * 8 + i]] *= 106;\n    }\n    for (let i = 0; i < 8; i += 1) {\n      qtab[table[0 + 8 * i]] *= 90;\n      qtab[table[4 + 8 * i]] *= 90;\n      qtab[table[2 + 8 * i]] *= 118;\n      qtab[table[6 + 8 * i]] *= 49;\n      qtab[table[5 + 8 * i]] *= 71;\n      qtab[table[1 + 8 * i]] *= 126;\n      qtab[table[7 + 8 * i]] *= 25;\n      qtab[table[3 + 8 * i]] *= 106;\n    }\n    for (let i = 0; i < 64; i += 1) {\n      qtab[i] >>= 6;\n    }\n  };\n  read(data, table) {\n    let count = 0;\n    let temp;\n    let t;\n    let i;\n    const length = data.get16();\n    count += 2;\n    while (count < length) {\n      temp = data.get8();\n      count += 1;\n      t = temp & 15;\n      if (t > 3) {\n        throw new Error(\"ERROR: Quantization table ID > 3\");\n      }\n      this.precision[t] = temp >> 4;\n      if (this.precision[t] === 0) {\n        this.precision[t] = 8;\n      } else if (this.precision[t] === 1) {\n        this.precision[t] = 16;\n      } else {\n        throw new Error(\"ERROR: Quantization table precision error\");\n      }\n      this.tq[t] = 1;\n      if (this.precision[t] === 8) {\n        for (i = 0; i < 64; i += 1) {\n          if (count > length) {\n            throw new Error(\"ERROR: Quantization table format error\");\n          }\n          this.quantTables[t][i] = data.get8();\n          count += 1;\n        }\n        _QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);\n      } else {\n        for (i = 0; i < 64; i += 1) {\n          if (count > length) {\n            throw new Error(\"ERROR: Quantization table format error\");\n          }\n          this.quantTables[t][i] = data.get16();\n          count += 2;\n        }\n        _QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);\n      }\n    }\n    if (count !== length) {\n      throw new Error(\"ERROR: Quantization table error [count!=Lq]\");\n    }\n    return 1;\n  }\n};\n\n// src/scan-component.ts\nvar ScanComponent = {\n  acTabSel: 0,\n  // AC table selector\n  dcTabSel: 0,\n  // DC table selector\n  scanCompSel: 0\n  // Scan component selector\n};\n\n// src/scan-header.ts\nvar ScanHeader = class {\n  ah = 0;\n  al = 0;\n  numComp = 0;\n  // Number of components in the scan\n  selection = 0;\n  // Start of spectral or predictor selection\n  spectralEnd = 0;\n  // End of spectral selection\n  components = [];\n  read(data) {\n    let count = 0;\n    let i;\n    let temp;\n    const length = data.get16();\n    count += 2;\n    this.numComp = data.get8();\n    count += 1;\n    for (i = 0; i < this.numComp; i += 1) {\n      this.components[i] = { ...ScanComponent };\n      if (count > length) {\n        throw new Error(\"ERROR: scan header format error\");\n      }\n      this.components[i].scanCompSel = data.get8();\n      count += 1;\n      temp = data.get8();\n      count += 1;\n      this.components[i].dcTabSel = temp >> 4;\n      this.components[i].acTabSel = temp & 15;\n    }\n    this.selection = data.get8();\n    count += 1;\n    this.spectralEnd = data.get8();\n    count += 1;\n    temp = data.get8();\n    this.ah = temp >> 4;\n    this.al = temp & 15;\n    count += 1;\n    if (count !== length) {\n      throw new Error(\"ERROR: scan header format error [count!=Ns]\");\n    }\n    return 1;\n  }\n};\n\n// src/decoder.ts\nvar littleEndian = function() {\n  const buffer = new ArrayBuffer(2);\n  new DataView(buffer).setInt16(\n    0,\n    256,\n    true\n    /* littleEndian */\n  );\n  return new Int16Array(buffer)[0] === 256;\n}();\nvar Decoder = class _Decoder {\n  static IDCT_P = [\n    0,\n    5,\n    40,\n    16,\n    45,\n    2,\n    7,\n    42,\n    21,\n    56,\n    8,\n    61,\n    18,\n    47,\n    1,\n    4,\n    41,\n    23,\n    58,\n    13,\n    32,\n    24,\n    37,\n    10,\n    63,\n    17,\n    44,\n    3,\n    6,\n    43,\n    20,\n    57,\n    15,\n    34,\n    29,\n    48,\n    53,\n    26,\n    39,\n    9,\n    60,\n    19,\n    46,\n    22,\n    59,\n    12,\n    33,\n    31,\n    50,\n    55,\n    25,\n    36,\n    11,\n    62,\n    14,\n    35,\n    28,\n    49,\n    52,\n    27,\n    38,\n    30,\n    51,\n    54\n  ];\n  static TABLE = [\n    0,\n    1,\n    5,\n    6,\n    14,\n    15,\n    27,\n    28,\n    2,\n    4,\n    7,\n    13,\n    16,\n    26,\n    29,\n    42,\n    3,\n    8,\n    12,\n    17,\n    25,\n    30,\n    41,\n    43,\n    9,\n    11,\n    18,\n    24,\n    31,\n    40,\n    44,\n    53,\n    10,\n    19,\n    23,\n    32,\n    39,\n    45,\n    52,\n    54,\n    20,\n    22,\n    33,\n    38,\n    46,\n    51,\n    55,\n    60,\n    21,\n    34,\n    37,\n    47,\n    50,\n    56,\n    59,\n    61,\n    35,\n    36,\n    48,\n    49,\n    57,\n    58,\n    62,\n    63\n  ];\n  static MAX_HUFFMAN_SUBTREE = 50;\n  static MSB = 2147483648;\n  static RESTART_MARKER_BEGIN = 65488;\n  static RESTART_MARKER_END = 65495;\n  buffer = null;\n  stream = null;\n  frame = new FrameHeader();\n  huffTable = new HuffmanTable();\n  quantTable = new QuantizationTable();\n  scan = new ScanHeader();\n  DU = createArray(10, 4, 64);\n  // at most 10 data units in a MCU, at most 4 data units in one component\n  HuffTab = createArray(4, 2, 50 * 256);\n  IDCT_Source = [];\n  nBlock = [];\n  // number of blocks in the i-th Comp in a scan\n  acTab = createArray(10, 1);\n  // ac HuffTab for the i-th Comp in a scan\n  dcTab = createArray(10, 1);\n  // dc HuffTab for the i-th Comp in a scan\n  qTab = createArray(10, 1);\n  // quantization table for the i-th Comp in a scan\n  marker = 0;\n  markerIndex = 0;\n  numComp = 0;\n  restartInterval = 0;\n  selection = 0;\n  xDim = 0;\n  yDim = 0;\n  xLoc = 0;\n  yLoc = 0;\n  outputData = null;\n  restarting = false;\n  mask = 0;\n  numBytes = 0;\n  precision = void 0;\n  components = [];\n  getter = null;\n  setter = null;\n  output = null;\n  selector = null;\n  /**\n   * The Decoder constructor.\n   * @property {number} numBytes - number of bytes per component\n   * @type {Function}\n   */\n  constructor(buffer, numBytes) {\n    this.buffer = buffer ?? null;\n    this.numBytes = numBytes ?? 0;\n  }\n  /**\n   * Returns decompressed data.\n   */\n  decompress(buffer, offset, length) {\n    const result = this.decode(buffer, offset, length);\n    return result.buffer;\n  }\n  decode(buffer, offset, length, numBytes) {\n    let scanNum = 0;\n    const pred = [];\n    let i;\n    let compN;\n    const temp = [];\n    const index = [];\n    let mcuNum;\n    if (buffer) {\n      this.buffer = buffer;\n    }\n    if (numBytes !== void 0) {\n      this.numBytes = numBytes;\n    }\n    this.stream = new DataStream(this.buffer, offset, length);\n    this.buffer = null;\n    this.xLoc = 0;\n    this.yLoc = 0;\n    let current = this.stream.get16();\n    if (current !== 65496) {\n      throw new Error(\"Not a JPEG file\");\n    }\n    current = this.stream.get16();\n    while (current >> 4 !== 4092 || current === 65476) {\n      switch (current) {\n        case 65476:\n          this.huffTable.read(this.stream, this.HuffTab);\n          break;\n        case 65484:\n          throw new Error(\"Program doesn't support arithmetic coding. (format throw new IOException)\");\n        case 65499:\n          this.quantTable.read(this.stream, _Decoder.TABLE);\n          break;\n        case 65501:\n          this.restartInterval = this.readNumber() ?? 0;\n          break;\n        case 65504:\n        case 65505:\n        case 65506:\n        case 65507:\n        case 65508:\n        case 65509:\n        case 65510:\n        case 65511:\n        case 65512:\n        case 65513:\n        case 65514:\n        case 65515:\n        case 65516:\n        case 65517:\n        case 65518:\n        case 65519:\n          this.readApp();\n          break;\n        case 65534:\n          this.readComment();\n          break;\n        default:\n          if (current >> 8 !== 255) {\n            throw new Error(\"ERROR: format throw new IOException! (decode)\");\n          }\n      }\n      current = this.stream.get16();\n    }\n    if (current < 65472 || current > 65479) {\n      throw new Error(\"ERROR: could not handle arithmetic code!\");\n    }\n    this.frame.read(this.stream);\n    current = this.stream.get16();\n    do {\n      while (current !== 65498) {\n        switch (current) {\n          case 65476:\n            this.huffTable.read(this.stream, this.HuffTab);\n            break;\n          case 65484:\n            throw new Error(\"Program doesn't support arithmetic coding. (format throw new IOException)\");\n          case 65499:\n            this.quantTable.read(this.stream, _Decoder.TABLE);\n            break;\n          case 65501:\n            this.restartInterval = this.readNumber() ?? 0;\n            break;\n          case 65504:\n          case 65505:\n          case 65506:\n          case 65507:\n          case 65508:\n          case 65509:\n          case 65510:\n          case 65511:\n          case 65512:\n          case 65513:\n          case 65514:\n          case 65515:\n          case 65516:\n          case 65517:\n          case 65518:\n          case 65519:\n            this.readApp();\n            break;\n          case 65534:\n            this.readComment();\n            break;\n          default:\n            if (current >> 8 !== 255) {\n              throw new Error(\"ERROR: format throw new IOException! (Parser.decode)\");\n            }\n        }\n        current = this.stream.get16();\n      }\n      this.precision = this.frame.precision;\n      this.components = this.frame.components;\n      if (!this.numBytes) {\n        this.numBytes = Math.round(Math.ceil(this.precision / 8));\n      }\n      if (this.numBytes === 1) {\n        this.mask = 255;\n      } else {\n        this.mask = 65535;\n      }\n      this.scan.read(this.stream);\n      this.numComp = this.scan.numComp;\n      this.selection = this.scan.selection;\n      if (this.numBytes === 1) {\n        if (this.numComp === 3) {\n          this.getter = this.getValueRGB;\n          this.setter = this.setValueRGB;\n          this.output = this.outputRGB;\n        } else {\n          this.getter = this.getValue8;\n          this.setter = this.setValue8;\n          this.output = this.outputSingle;\n        }\n      } else {\n        this.getter = this.getValue8;\n        this.setter = this.setValue8;\n        this.output = this.outputSingle;\n      }\n      switch (this.selection) {\n        case 2:\n          this.selector = this.select2;\n          break;\n        case 3:\n          this.selector = this.select3;\n          break;\n        case 4:\n          this.selector = this.select4;\n          break;\n        case 5:\n          this.selector = this.select5;\n          break;\n        case 6:\n          this.selector = this.select6;\n          break;\n        case 7:\n          this.selector = this.select7;\n          break;\n        default:\n          this.selector = this.select1;\n          break;\n      }\n      for (i = 0; i < this.numComp; i += 1) {\n        compN = this.scan.components[i].scanCompSel;\n        this.qTab[i] = this.quantTable.quantTables[this.components[compN].quantTableSel];\n        this.nBlock[i] = this.components[compN].vSamp * this.components[compN].hSamp;\n        this.dcTab[i] = this.HuffTab[this.scan.components[i].dcTabSel][0];\n        this.acTab[i] = this.HuffTab[this.scan.components[i].acTabSel][1];\n      }\n      this.xDim = this.frame.dimX;\n      this.yDim = this.frame.dimY;\n      if (this.numBytes === 1) {\n        this.outputData = new Uint8Array(new ArrayBuffer(this.xDim * this.yDim * this.numBytes * this.numComp));\n      } else {\n        this.outputData = new Uint16Array(new ArrayBuffer(this.xDim * this.yDim * this.numBytes * this.numComp));\n      }\n      scanNum += 1;\n      while (true) {\n        temp[0] = 0;\n        index[0] = 0;\n        for (i = 0; i < 10; i += 1) {\n          pred[i] = 1 << this.precision - 1;\n        }\n        if (this.restartInterval === 0) {\n          current = this.decodeUnit(pred, temp, index);\n          while (current === 0 && this.xLoc < this.xDim && this.yLoc < this.yDim) {\n            this.output(pred);\n            current = this.decodeUnit(pred, temp, index);\n          }\n          break;\n        }\n        for (mcuNum = 0; mcuNum < this.restartInterval; mcuNum += 1) {\n          this.restarting = mcuNum === 0;\n          current = this.decodeUnit(pred, temp, index);\n          this.output(pred);\n          if (current !== 0) {\n            break;\n          }\n        }\n        if (current === 0) {\n          if (this.markerIndex !== 0) {\n            current = 65280 | this.marker;\n            this.markerIndex = 0;\n          } else {\n            current = this.stream.get16();\n          }\n        }\n        if (!(current >= _Decoder.RESTART_MARKER_BEGIN && current <= _Decoder.RESTART_MARKER_END)) {\n          break;\n        }\n      }\n      if (current === 65500 && scanNum === 1) {\n        this.readNumber();\n        current = this.stream.get16();\n      }\n    } while (current !== 65497 && this.xLoc < this.xDim && this.yLoc < this.yDim && scanNum === 0);\n    return this.outputData;\n  }\n  decodeUnit(prev, temp, index) {\n    if (this.numComp === 1) {\n      return this.decodeSingle(prev, temp, index);\n    } else if (this.numComp === 3) {\n      return this.decodeRGB(prev, temp, index);\n    } else {\n      return -1;\n    }\n  }\n  select1(compOffset) {\n    return this.getPreviousX(compOffset);\n  }\n  select2(compOffset) {\n    return this.getPreviousY(compOffset);\n  }\n  select3(compOffset) {\n    return this.getPreviousXY(compOffset);\n  }\n  select4(compOffset) {\n    return this.getPreviousX(compOffset) + this.getPreviousY(compOffset) - this.getPreviousXY(compOffset);\n  }\n  select5(compOffset) {\n    return this.getPreviousX(compOffset) + (this.getPreviousY(compOffset) - this.getPreviousXY(compOffset) >> 1);\n  }\n  select6(compOffset) {\n    return this.getPreviousY(compOffset) + (this.getPreviousX(compOffset) - this.getPreviousXY(compOffset) >> 1);\n  }\n  select7(compOffset) {\n    return (this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) / 2;\n  }\n  decodeRGB(prev, temp, index) {\n    if (this.selector === null)\n      throw new Error(\"decode hasn't run yet\");\n    let actab, dctab, qtab, ctrC, i, k, j;\n    prev[0] = this.selector(0);\n    prev[1] = this.selector(1);\n    prev[2] = this.selector(2);\n    for (ctrC = 0; ctrC < this.numComp; ctrC += 1) {\n      qtab = this.qTab[ctrC];\n      actab = this.acTab[ctrC];\n      dctab = this.dcTab[ctrC];\n      for (i = 0; i < this.nBlock[ctrC]; i += 1) {\n        for (k = 0; k < this.IDCT_Source.length; k += 1) {\n          this.IDCT_Source[k] = 0;\n        }\n        let value = this.getHuffmanValue(dctab, temp, index);\n        if (value >= 65280) {\n          return value;\n        }\n        prev[ctrC] = this.IDCT_Source[0] = prev[ctrC] + this.getn(index, value, temp, index);\n        this.IDCT_Source[0] *= qtab[0];\n        for (j = 1; j < 64; j += 1) {\n          value = this.getHuffmanValue(actab, temp, index);\n          if (value >= 65280) {\n            return value;\n          }\n          j += value >> 4;\n          if ((value & 15) === 0) {\n            if (value >> 4 === 0) {\n              break;\n            }\n          } else {\n            this.IDCT_Source[_Decoder.IDCT_P[j]] = this.getn(index, value & 15, temp, index) * qtab[j];\n          }\n        }\n      }\n    }\n    return 0;\n  }\n  decodeSingle(prev, temp, index) {\n    if (this.selector === null)\n      throw new Error(\"decode hasn't run yet\");\n    let value, i, n, nRestart;\n    if (this.restarting) {\n      this.restarting = false;\n      prev[0] = 1 << this.frame.precision - 1;\n    } else {\n      prev[0] = this.selector();\n    }\n    for (i = 0; i < this.nBlock[0]; i += 1) {\n      value = this.getHuffmanValue(this.dcTab[0], temp, index);\n      if (value >= 65280) {\n        return value;\n      }\n      n = this.getn(prev, value, temp, index);\n      nRestart = n >> 8;\n      if (nRestart >= _Decoder.RESTART_MARKER_BEGIN && nRestart <= _Decoder.RESTART_MARKER_END) {\n        return nRestart;\n      }\n      prev[0] += n;\n    }\n    return 0;\n  }\n  //\tHuffman table for fast search: (HuffTab) 8-bit Look up table 2-layer search architecture, 1st-layer represent 256 node (8 bits) if codeword-length > 8\n  //\tbits, then the entry of 1st-layer = (# of 2nd-layer table) | MSB and it is stored in the 2nd-layer Size of tables in each layer are 256.\n  //\tHuffTab[*][*][0-256] is always the only 1st-layer table.\n  //\n  //\tAn entry can be: (1) (# of 2nd-layer table) | MSB , for code length > 8 in 1st-layer (2) (Code length) << 8 | HuffVal\n  //\n  //\tHuffmanValue(table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)\n  //\t                ):\n  //\t    return: Huffman Value of table\n  //\t            0xFF?? if it receives a MARKER\n  //\t    Parameter:  table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)\n  //\t                temp    temp storage for remainded bits\n  //\t                index   index to bit of temp\n  //\t                in      FILE pointer\n  //\t    Effect:\n  //\t        temp  store new remainded bits\n  //\t        index change to new index\n  //\t        in    change to new position\n  //\t    NOTE:\n  //\t      Initial by   temp=0; index=0;\n  //\t    NOTE: (explain temp and index)\n  //\t      temp: is always in the form at calling time or returning time\n  //\t       |  byte 4  |  byte 3  |  byte 2  |  byte 1  |\n  //\t       |     0    |     0    | 00000000 | 00000??? |  if not a MARKER\n  //\t                                               ^index=3 (from 0 to 15)\n  //\t                                               321\n  //\t    NOTE (marker and marker_index):\n  //\t      If get a MARKER from 'in', marker=the low-byte of the MARKER\n  //\t        and marker_index=9\n  //\t      If marker_index=9 then index is always > 8, or HuffmanValue()\n  //\t        will not be called\n  getHuffmanValue(table, temp, index) {\n    let code, input;\n    const mask = 65535;\n    if (!this.stream)\n      throw new Error(\"stream not initialized\");\n    if (index[0] < 8) {\n      temp[0] <<= 8;\n      input = this.stream.get8();\n      if (input === 255) {\n        this.marker = this.stream.get8();\n        if (this.marker !== 0) {\n          this.markerIndex = 9;\n        }\n      }\n      temp[0] |= input;\n    } else {\n      index[0] -= 8;\n    }\n    code = table[temp[0] >> index[0]];\n    if ((code & _Decoder.MSB) !== 0) {\n      if (this.markerIndex !== 0) {\n        this.markerIndex = 0;\n        return 65280 | this.marker;\n      }\n      temp[0] &= mask >> 16 - index[0];\n      temp[0] <<= 8;\n      input = this.stream.get8();\n      if (input === 255) {\n        this.marker = this.stream.get8();\n        if (this.marker !== 0) {\n          this.markerIndex = 9;\n        }\n      }\n      temp[0] |= input;\n      code = table[(code & 255) * 256 + (temp[0] >> index[0])];\n      index[0] += 8;\n    }\n    index[0] += 8 - (code >> 8);\n    if (index[0] < 0) {\n      throw new Error(\"index=\" + index[0] + \" temp=\" + temp[0] + \" code=\" + code + \" in HuffmanValue()\");\n    }\n    if (index[0] < this.markerIndex) {\n      this.markerIndex = 0;\n      return 65280 | this.marker;\n    }\n    temp[0] &= mask >> 16 - index[0];\n    return code & 255;\n  }\n  getn(PRED, n, temp, index) {\n    let result, input;\n    const one = 1;\n    const n_one = -1;\n    const mask = 65535;\n    if (this.stream === null)\n      throw new Error(\"stream not initialized\");\n    if (n === 0) {\n      return 0;\n    }\n    if (n === 16) {\n      if (PRED[0] >= 0) {\n        return -32768;\n      } else {\n        return 32768;\n      }\n    }\n    index[0] -= n;\n    if (index[0] >= 0) {\n      if (index[0] < this.markerIndex && !this.isLastPixel()) {\n        this.markerIndex = 0;\n        return (65280 | this.marker) << 8;\n      }\n      result = temp[0] >> index[0];\n      temp[0] &= mask >> 16 - index[0];\n    } else {\n      temp[0] <<= 8;\n      input = this.stream.get8();\n      if (input === 255) {\n        this.marker = this.stream.get8();\n        if (this.marker !== 0) {\n          this.markerIndex = 9;\n        }\n      }\n      temp[0] |= input;\n      index[0] += 8;\n      if (index[0] < 0) {\n        if (this.markerIndex !== 0) {\n          this.markerIndex = 0;\n          return (65280 | this.marker) << 8;\n        }\n        temp[0] <<= 8;\n        input = this.stream.get8();\n        if (input === 255) {\n          this.marker = this.stream.get8();\n          if (this.marker !== 0) {\n            this.markerIndex = 9;\n          }\n        }\n        temp[0] |= input;\n        index[0] += 8;\n      }\n      if (index[0] < 0) {\n        throw new Error(\"index=\" + index[0] + \" in getn()\");\n      }\n      if (index[0] < this.markerIndex) {\n        this.markerIndex = 0;\n        return (65280 | this.marker) << 8;\n      }\n      result = temp[0] >> index[0];\n      temp[0] &= mask >> 16 - index[0];\n    }\n    if (result < one << n - 1) {\n      result += (n_one << n) + 1;\n    }\n    return result;\n  }\n  getPreviousX(compOffset = 0) {\n    if (this.getter === null)\n      throw new Error(\"decode hasn't run yet\");\n    if (this.xLoc > 0) {\n      return this.getter(this.yLoc * this.xDim + this.xLoc - 1, compOffset);\n    } else if (this.yLoc > 0) {\n      return this.getPreviousY(compOffset);\n    } else {\n      return 1 << this.frame.precision - 1;\n    }\n  }\n  getPreviousXY(compOffset = 0) {\n    if (this.getter === null)\n      throw new Error(\"decode hasn't run yet\");\n    if (this.xLoc > 0 && this.yLoc > 0) {\n      return this.getter((this.yLoc - 1) * this.xDim + this.xLoc - 1, compOffset);\n    } else {\n      return this.getPreviousY(compOffset);\n    }\n  }\n  getPreviousY(compOffset = 0) {\n    if (this.getter === null)\n      throw new Error(\"decode hasn't run yet\");\n    if (this.yLoc > 0) {\n      return this.getter((this.yLoc - 1) * this.xDim + this.xLoc, compOffset);\n    } else {\n      return this.getPreviousX(compOffset);\n    }\n  }\n  isLastPixel() {\n    return this.xLoc === this.xDim - 1 && this.yLoc === this.yDim - 1;\n  }\n  outputSingle(PRED) {\n    if (this.setter === null)\n      throw new Error(\"decode hasn't run yet\");\n    if (this.xLoc < this.xDim && this.yLoc < this.yDim) {\n      this.setter(this.yLoc * this.xDim + this.xLoc, this.mask & PRED[0]);\n      this.xLoc += 1;\n      if (this.xLoc >= this.xDim) {\n        this.yLoc += 1;\n        this.xLoc = 0;\n      }\n    }\n  }\n  outputRGB(PRED) {\n    if (this.setter === null)\n      throw new Error(\"decode hasn't run yet\");\n    const offset = this.yLoc * this.xDim + this.xLoc;\n    if (this.xLoc < this.xDim && this.yLoc < this.yDim) {\n      this.setter(offset, PRED[0], 0);\n      this.setter(offset, PRED[1], 1);\n      this.setter(offset, PRED[2], 2);\n      this.xLoc += 1;\n      if (this.xLoc >= this.xDim) {\n        this.yLoc += 1;\n        this.xLoc = 0;\n      }\n    }\n  }\n  setValue8(index, val) {\n    if (!this.outputData)\n      throw new Error(\"output data not ready\");\n    if (littleEndian) {\n      this.outputData[index] = val;\n    } else {\n      this.outputData[index] = (val & 255) << 8 | val >> 8 & 255;\n    }\n  }\n  getValue8(index) {\n    if (this.outputData === null)\n      throw new Error(\"output data not ready\");\n    if (littleEndian) {\n      return this.outputData[index];\n    } else {\n      const val = this.outputData[index];\n      return (val & 255) << 8 | val >> 8 & 255;\n    }\n  }\n  setValueRGB(index, val, compOffset = 0) {\n    if (this.outputData === null)\n      return;\n    this.outputData[index * 3 + compOffset] = val;\n  }\n  getValueRGB(index, compOffset) {\n    if (this.outputData === null)\n      throw new Error(\"output data not ready\");\n    return this.outputData[index * 3 + compOffset];\n  }\n  readApp() {\n    if (this.stream === null)\n      return null;\n    let count = 0;\n    const length = this.stream.get16();\n    count += 2;\n    while (count < length) {\n      this.stream.get8();\n      count += 1;\n    }\n    return length;\n  }\n  readComment() {\n    if (this.stream === null)\n      return null;\n    let sb = \"\";\n    let count = 0;\n    const length = this.stream.get16();\n    count += 2;\n    while (count < length) {\n      sb += this.stream.get8();\n      count += 1;\n    }\n    return sb;\n  }\n  readNumber() {\n    if (this.stream === null)\n      return null;\n    const Ld = this.stream.get16();\n    if (Ld !== 4) {\n      throw new Error(\"ERROR: Define number format throw new IOException [Ld!=4]\");\n    }\n    return this.stream.get16();\n  }\n};\n\n//# sourceMappingURL=lossless.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qcGVnLWxvc3NsZXNzLWRlY29kZXItanMvcmVsZWFzZS9sb3NzbGVzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsa0JBQWtCLFVBQVU7QUFDNUIsb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixrQkFBa0IsVUFBVTtBQUM1QixvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QyxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3N1bWl0YXRoYW5pL0Rlc2t0b3AvTmV4dF9EaWNvbS9Gcm9udGVuZC9ub2RlX21vZHVsZXMvanBlZy1sb3NzbGVzcy1kZWNvZGVyLWpzL3JlbGVhc2UvbG9zc2xlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3JjL2NvbXBvbmVudC1zcGVjLnRzXG52YXIgQ29tcG9uZW50U3BlYyA9IHtcbiAgaFNhbXA6IDAsXG4gIHF1YW50VGFibGVTZWw6IDAsXG4gIHZTYW1wOiAwXG59O1xuXG4vLyBzcmMvZGF0YS1zdHJlYW0udHNcbnZhciBEYXRhU3RyZWFtID0gY2xhc3Mge1xuICBidWZmZXI7XG4gIGluZGV4O1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICB9XG4gIGdldDE2KCkge1xuICAgIGNvbnN0IHZhbHVlID0gKHRoaXMuYnVmZmVyW3RoaXMuaW5kZXhdIDw8IDgpICsgdGhpcy5idWZmZXJbdGhpcy5pbmRleCArIDFdO1xuICAgIHRoaXMuaW5kZXggKz0gMjtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZ2V0OCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYnVmZmVyW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy9mcmFtZS1oZWFkZXIudHNcbnZhciBGcmFtZUhlYWRlciA9IGNsYXNzIHtcbiAgZGltWCA9IDA7XG4gIGRpbVkgPSAwO1xuICBudW1Db21wID0gMDtcbiAgcHJlY2lzaW9uID0gMDtcbiAgY29tcG9uZW50cyA9IFtdO1xuICByZWFkKGRhdGEpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCB0ZW1wO1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEuZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuICAgIHRoaXMucHJlY2lzaW9uID0gZGF0YS5nZXQ4KCk7XG4gICAgY291bnQgKz0gMTtcbiAgICB0aGlzLmRpbVkgPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcbiAgICB0aGlzLmRpbVggPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcbiAgICB0aGlzLm51bUNvbXAgPSBkYXRhLmdldDgoKTtcbiAgICBjb3VudCArPSAxO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMubnVtQ29tcDsgaSArPSAxKSB7XG4gICAgICBpZiAoY291bnQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZyYW1lIGZvcm1hdCBlcnJvclwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGMgPSBkYXRhLmdldDgoKTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBpZiAoY291bnQgPj0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBmcmFtZSBmb3JtYXQgZXJyb3IgW2M+PUxmXVwiKTtcbiAgICAgIH1cbiAgICAgIHRlbXAgPSBkYXRhLmdldDgoKTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBpZiAoIXRoaXMuY29tcG9uZW50c1tjXSkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudHNbY10gPSB7IC4uLkNvbXBvbmVudFNwZWMgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29tcG9uZW50c1tjXS5oU2FtcCA9IHRlbXAgPj4gNDtcbiAgICAgIHRoaXMuY29tcG9uZW50c1tjXS52U2FtcCA9IHRlbXAgJiAxNTtcbiAgICAgIHRoaXMuY29tcG9uZW50c1tjXS5xdWFudFRhYmxlU2VsID0gZGF0YS5nZXQ4KCk7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBpZiAoY291bnQgIT09IGxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZyYW1lIGZvcm1hdCBlcnJvciBbTGYhPWNvdW50XVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgY3JjMzI6ICgpID0+IGNyYzMyLFxuICBjcmNUYWJsZTogKCkgPT4gY3JjVGFibGUsXG4gIGNyZWF0ZUFycmF5OiAoKSA9PiBjcmVhdGVBcnJheSxcbiAgbWFrZUNSQ1RhYmxlOiAoKSA9PiBtYWtlQ1JDVGFibGVcbn0pO1xudmFyIGNyZWF0ZUFycmF5ID0gKC4uLmRpbWVuc2lvbnMpID0+IHtcbiAgaWYgKGRpbWVuc2lvbnMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGRpbSA9IGRpbWVuc2lvbnNbMF07XG4gICAgY29uc3QgcmVzdCA9IGRpbWVuc2lvbnMuc2xpY2UoMSk7XG4gICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbTsgaSsrKSB7XG4gICAgICBuZXdBcnJheVtpXSA9IGNyZWF0ZUFycmF5KC4uLnJlc3QpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5KGRpbWVuc2lvbnNbMF0pLmZpbGwodm9pZCAwKTtcbiAgfVxufTtcbnZhciBtYWtlQ1JDVGFibGUgPSBmdW5jdGlvbigpIHtcbiAgbGV0IGM7XG4gIGNvbnN0IGNyY1RhYmxlMiA9IFtdO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSBjICYgMSA/IDM5ODgyOTIzODQgXiBjID4+PiAxIDogYyA+Pj4gMTtcbiAgICB9XG4gICAgY3JjVGFibGUyW25dID0gYztcbiAgfVxuICByZXR1cm4gY3JjVGFibGUyO1xufTtcbnZhciBjcmNUYWJsZSA9IG1ha2VDUkNUYWJsZSgpO1xudmFyIGNyYzMyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIGNvbnN0IHVpbnQ4dmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIGxldCBjcmMgPSAwIF4gLTE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDh2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgY3JjID0gY3JjID4+PiA4IF4gY3JjVGFibGVbKGNyYyBeIHVpbnQ4dmlld1tpXSkgJiAyNTVdO1xuICB9XG4gIHJldHVybiAoY3JjIF4gLTEpID4+PiAwO1xufTtcblxuLy8gc3JjL2h1ZmZtYW4tdGFibGUudHNcbnZhciBIdWZmbWFuVGFibGUgPSBjbGFzcyBfSHVmZm1hblRhYmxlIHtcbiAgc3RhdGljIE1TQiA9IDIxNDc0ODM2NDg7XG4gIGw7XG4gIHRoO1xuICB2O1xuICB0YztcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5sID0gY3JlYXRlQXJyYXkoNCwgMiwgMTYpO1xuICAgIHRoaXMudGggPSBbMCwgMCwgMCwgMF07XG4gICAgdGhpcy52ID0gY3JlYXRlQXJyYXkoNCwgMiwgMTYsIDIwMCk7XG4gICAgdGhpcy50YyA9IFtcbiAgICAgIFswLCAwXSxcbiAgICAgIFswLCAwXSxcbiAgICAgIFswLCAwXSxcbiAgICAgIFswLCAwXVxuICAgIF07XG4gIH1cbiAgcmVhZChkYXRhLCBIdWZmVGFiKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgdGVtcDtcbiAgICBsZXQgdDtcbiAgICBsZXQgYztcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcbiAgICB3aGlsZSAoY291bnQgPCBsZW5ndGgpIHtcbiAgICAgIHRlbXAgPSBkYXRhLmdldDgoKTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICB0ID0gdGVtcCAmIDE1O1xuICAgICAgaWYgKHQgPiAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBIdWZmbWFuIHRhYmxlIElEID4gM1wiKTtcbiAgICAgIH1cbiAgICAgIGMgPSB0ZW1wID4+IDQ7XG4gICAgICBpZiAoYyA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IEh1ZmZtYW4gdGFibGUgW1RhYmxlIGNsYXNzID4gMiBdXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy50aFt0XSA9IDE7XG4gICAgICB0aGlzLnRjW3RdW2NdID0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMubFt0XVtjXVtpXSA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICBjb3VudCArPSAxO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMubFt0XVtjXVtpXTsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogSHVmZm1hbiB0YWJsZSBmb3JtYXQgZXJyb3IgW2NvdW50PkxoXVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy52W3RdW2NdW2ldW2pdID0gZGF0YS5nZXQ4KCk7XG4gICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY291bnQgIT09IGxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IEh1ZmZtYW4gdGFibGUgZm9ybWF0IGVycm9yIFtjb3VudCE9TGZdXCIpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgMjsgaiArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLnRjW2ldW2pdICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5idWlsZEh1ZmZUYWJsZShIdWZmVGFiW2ldW2pdLCB0aGlzLmxbaV1bal0sIHRoaXMudltpXVtqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgLy9cdEJ1aWxkX0h1ZmZUYWIoKVxuICAvL1x0UGFyYW1ldGVyOiAgdCAgICAgICB0YWJsZSBJRFxuICAvL1x0ICAgICAgICAgICAgYyAgICAgICB0YWJsZSBjbGFzcyAoIDAgZm9yIERDLCAxIGZvciBBQyApXG4gIC8vXHQgICAgICAgICAgICBMW2ldICAgICMgb2YgY29kZXdvcmRzIHdoaWNoIGxlbmd0aCBpcyBpXG4gIC8vXHQgICAgICAgICAgICBWW2ldW2pdIEh1ZmZtYW4gVmFsdWUgKGxlbmd0aD1pKVxuICAvL1x0RWZmZWN0OlxuICAvL1x0ICAgIGJ1aWxkIHVwIEh1ZmZUYWJbdF1bY10gdXNpbmcgTCBhbmQgVi5cbiAgYnVpbGRIdWZmVGFibGUodGFiLCBMLCBWKSB7XG4gICAgbGV0IGN1cnJlbnRUYWJsZSwgaywgaSwgaiwgbjtcbiAgICBjb25zdCB0ZW1wID0gMjU2O1xuICAgIGsgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBMW2ldOyBqICs9IDEpIHtcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IHRlbXAgPj4gaSArIDE7IG4gKz0gMSkge1xuICAgICAgICAgIHRhYltrXSA9IFZbaV1bal0gfCBpICsgMSA8PCA4O1xuICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAxOyBrIDwgMjU2OyBpICs9IDEsIGsgKz0gMSkge1xuICAgICAgdGFiW2tdID0gaSB8IF9IdWZmbWFuVGFibGUuTVNCO1xuICAgIH1cbiAgICBjdXJyZW50VGFibGUgPSAxO1xuICAgIGsgPSAwO1xuICAgIGZvciAoaSA9IDg7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgTFtpXTsgaiArPSAxKSB7XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCB0ZW1wID4+IGkgLSA3OyBuICs9IDEpIHtcbiAgICAgICAgICB0YWJbY3VycmVudFRhYmxlICogMjU2ICsga10gPSBWW2ldW2pdIHwgaSArIDEgPDwgODtcbiAgICAgICAgICBrICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPj0gMjU2KSB7XG4gICAgICAgICAgaWYgKGsgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBIdWZmbWFuIHRhYmxlIGVycm9yKDEpIVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgayA9IDA7XG4gICAgICAgICAgY3VycmVudFRhYmxlICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9xdWFudGl6YXRpb24tdGFibGUudHNcbnZhciBRdWFudGl6YXRpb25UYWJsZSA9IGNsYXNzIF9RdWFudGl6YXRpb25UYWJsZSB7XG4gIHByZWNpc2lvbiA9IFtdO1xuICAvLyBRdWFudGl6YXRpb24gcHJlY2lzaW9uIDggb3IgMTZcbiAgdHEgPSBbMCwgMCwgMCwgMF07XG4gIC8vIDE6IHRoaXMgdGFibGUgaXMgcHJlc2VudGVkXG4gIHF1YW50VGFibGVzID0gY3JlYXRlQXJyYXkoNCwgNjQpO1xuICAvLyBUYWJsZXNcbiAgc3RhdGljIGVuaGFuY2VRdWFudGl6YXRpb25UYWJsZSA9IGZ1bmN0aW9uKHF0YWIsIHRhYmxlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICAgIHF0YWJbdGFibGVbMCAqIDggKyBpXV0gKj0gOTA7XG4gICAgICBxdGFiW3RhYmxlWzQgKiA4ICsgaV1dICo9IDkwO1xuICAgICAgcXRhYlt0YWJsZVsyICogOCArIGldXSAqPSAxMTg7XG4gICAgICBxdGFiW3RhYmxlWzYgKiA4ICsgaV1dICo9IDQ5O1xuICAgICAgcXRhYlt0YWJsZVs1ICogOCArIGldXSAqPSA3MTtcbiAgICAgIHF0YWJbdGFibGVbMSAqIDggKyBpXV0gKj0gMTI2O1xuICAgICAgcXRhYlt0YWJsZVs3ICogOCArIGldXSAqPSAyNTtcbiAgICAgIHF0YWJbdGFibGVbMyAqIDggKyBpXV0gKj0gMTA2O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgICAgcXRhYlt0YWJsZVswICsgOCAqIGldXSAqPSA5MDtcbiAgICAgIHF0YWJbdGFibGVbNCArIDggKiBpXV0gKj0gOTA7XG4gICAgICBxdGFiW3RhYmxlWzIgKyA4ICogaV1dICo9IDExODtcbiAgICAgIHF0YWJbdGFibGVbNiArIDggKiBpXV0gKj0gNDk7XG4gICAgICBxdGFiW3RhYmxlWzUgKyA4ICogaV1dICo9IDcxO1xuICAgICAgcXRhYlt0YWJsZVsxICsgOCAqIGldXSAqPSAxMjY7XG4gICAgICBxdGFiW3RhYmxlWzcgKyA4ICogaV1dICo9IDI1O1xuICAgICAgcXRhYlt0YWJsZVszICsgOCAqIGldXSAqPSAxMDY7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkgKz0gMSkge1xuICAgICAgcXRhYltpXSA+Pj0gNjtcbiAgICB9XG4gIH07XG4gIHJlYWQoZGF0YSwgdGFibGUpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCB0ZW1wO1xuICAgIGxldCB0O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEuZ2V0MTYoKTtcbiAgICBjb3VudCArPSAyO1xuICAgIHdoaWxlIChjb3VudCA8IGxlbmd0aCkge1xuICAgICAgdGVtcCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgY291bnQgKz0gMTtcbiAgICAgIHQgPSB0ZW1wICYgMTU7XG4gICAgICBpZiAodCA+IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IFF1YW50aXphdGlvbiB0YWJsZSBJRCA+IDNcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnByZWNpc2lvblt0XSA9IHRlbXAgPj4gNDtcbiAgICAgIGlmICh0aGlzLnByZWNpc2lvblt0XSA9PT0gMCkge1xuICAgICAgICB0aGlzLnByZWNpc2lvblt0XSA9IDg7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uW3RdID09PSAxKSB7XG4gICAgICAgIHRoaXMucHJlY2lzaW9uW3RdID0gMTY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogUXVhbnRpemF0aW9uIHRhYmxlIHByZWNpc2lvbiBlcnJvclwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHFbdF0gPSAxO1xuICAgICAgaWYgKHRoaXMucHJlY2lzaW9uW3RdID09PSA4KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogUXVhbnRpemF0aW9uIHRhYmxlIGZvcm1hdCBlcnJvclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5xdWFudFRhYmxlc1t0XVtpXSA9IGRhdGEuZ2V0OCgpO1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgX1F1YW50aXphdGlvblRhYmxlLmVuaGFuY2VRdWFudGl6YXRpb25UYWJsZSh0aGlzLnF1YW50VGFibGVzW3RdLCB0YWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChjb3VudCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IFF1YW50aXphdGlvbiB0YWJsZSBmb3JtYXQgZXJyb3JcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucXVhbnRUYWJsZXNbdF1baV0gPSBkYXRhLmdldDE2KCk7XG4gICAgICAgICAgY291bnQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBfUXVhbnRpemF0aW9uVGFibGUuZW5oYW5jZVF1YW50aXphdGlvblRhYmxlKHRoaXMucXVhbnRUYWJsZXNbdF0sIHRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvdW50ICE9PSBsZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBRdWFudGl6YXRpb24gdGFibGUgZXJyb3IgW2NvdW50IT1McV1cIik7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG59O1xuXG4vLyBzcmMvc2Nhbi1jb21wb25lbnQudHNcbnZhciBTY2FuQ29tcG9uZW50ID0ge1xuICBhY1RhYlNlbDogMCxcbiAgLy8gQUMgdGFibGUgc2VsZWN0b3JcbiAgZGNUYWJTZWw6IDAsXG4gIC8vIERDIHRhYmxlIHNlbGVjdG9yXG4gIHNjYW5Db21wU2VsOiAwXG4gIC8vIFNjYW4gY29tcG9uZW50IHNlbGVjdG9yXG59O1xuXG4vLyBzcmMvc2Nhbi1oZWFkZXIudHNcbnZhciBTY2FuSGVhZGVyID0gY2xhc3Mge1xuICBhaCA9IDA7XG4gIGFsID0gMDtcbiAgbnVtQ29tcCA9IDA7XG4gIC8vIE51bWJlciBvZiBjb21wb25lbnRzIGluIHRoZSBzY2FuXG4gIHNlbGVjdGlvbiA9IDA7XG4gIC8vIFN0YXJ0IG9mIHNwZWN0cmFsIG9yIHByZWRpY3RvciBzZWxlY3Rpb25cbiAgc3BlY3RyYWxFbmQgPSAwO1xuICAvLyBFbmQgb2Ygc3BlY3RyYWwgc2VsZWN0aW9uXG4gIGNvbXBvbmVudHMgPSBbXTtcbiAgcmVhZChkYXRhKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgaTtcbiAgICBsZXQgdGVtcDtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcbiAgICB0aGlzLm51bUNvbXAgPSBkYXRhLmdldDgoKTtcbiAgICBjb3VudCArPSAxO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm51bUNvbXA7IGkgKz0gMSkge1xuICAgICAgdGhpcy5jb21wb25lbnRzW2ldID0geyAuLi5TY2FuQ29tcG9uZW50IH07XG4gICAgICBpZiAoY291bnQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IHNjYW4gaGVhZGVyIGZvcm1hdCBlcnJvclwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29tcG9uZW50c1tpXS5zY2FuQ29tcFNlbCA9IGRhdGEuZ2V0OCgpO1xuICAgICAgY291bnQgKz0gMTtcbiAgICAgIHRlbXAgPSBkYXRhLmdldDgoKTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbaV0uZGNUYWJTZWwgPSB0ZW1wID4+IDQ7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbaV0uYWNUYWJTZWwgPSB0ZW1wICYgMTU7XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0aW9uID0gZGF0YS5nZXQ4KCk7XG4gICAgY291bnQgKz0gMTtcbiAgICB0aGlzLnNwZWN0cmFsRW5kID0gZGF0YS5nZXQ4KCk7XG4gICAgY291bnQgKz0gMTtcbiAgICB0ZW1wID0gZGF0YS5nZXQ4KCk7XG4gICAgdGhpcy5haCA9IHRlbXAgPj4gNDtcbiAgICB0aGlzLmFsID0gdGVtcCAmIDE1O1xuICAgIGNvdW50ICs9IDE7XG4gICAgaWYgKGNvdW50ICE9PSBsZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBzY2FuIGhlYWRlciBmb3JtYXQgZXJyb3IgW2NvdW50IT1Oc11cIik7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG59O1xuXG4vLyBzcmMvZGVjb2Rlci50c1xudmFyIGxpdHRsZUVuZGlhbiA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gIG5ldyBEYXRhVmlldyhidWZmZXIpLnNldEludDE2KFxuICAgIDAsXG4gICAgMjU2LFxuICAgIHRydWVcbiAgICAvKiBsaXR0bGVFbmRpYW4gKi9cbiAgKTtcbiAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlcilbMF0gPT09IDI1Njtcbn0oKTtcbnZhciBEZWNvZGVyID0gY2xhc3MgX0RlY29kZXIge1xuICBzdGF0aWMgSURDVF9QID0gW1xuICAgIDAsXG4gICAgNSxcbiAgICA0MCxcbiAgICAxNixcbiAgICA0NSxcbiAgICAyLFxuICAgIDcsXG4gICAgNDIsXG4gICAgMjEsXG4gICAgNTYsXG4gICAgOCxcbiAgICA2MSxcbiAgICAxOCxcbiAgICA0NyxcbiAgICAxLFxuICAgIDQsXG4gICAgNDEsXG4gICAgMjMsXG4gICAgNTgsXG4gICAgMTMsXG4gICAgMzIsXG4gICAgMjQsXG4gICAgMzcsXG4gICAgMTAsXG4gICAgNjMsXG4gICAgMTcsXG4gICAgNDQsXG4gICAgMyxcbiAgICA2LFxuICAgIDQzLFxuICAgIDIwLFxuICAgIDU3LFxuICAgIDE1LFxuICAgIDM0LFxuICAgIDI5LFxuICAgIDQ4LFxuICAgIDUzLFxuICAgIDI2LFxuICAgIDM5LFxuICAgIDksXG4gICAgNjAsXG4gICAgMTksXG4gICAgNDYsXG4gICAgMjIsXG4gICAgNTksXG4gICAgMTIsXG4gICAgMzMsXG4gICAgMzEsXG4gICAgNTAsXG4gICAgNTUsXG4gICAgMjUsXG4gICAgMzYsXG4gICAgMTEsXG4gICAgNjIsXG4gICAgMTQsXG4gICAgMzUsXG4gICAgMjgsXG4gICAgNDksXG4gICAgNTIsXG4gICAgMjcsXG4gICAgMzgsXG4gICAgMzAsXG4gICAgNTEsXG4gICAgNTRcbiAgXTtcbiAgc3RhdGljIFRBQkxFID0gW1xuICAgIDAsXG4gICAgMSxcbiAgICA1LFxuICAgIDYsXG4gICAgMTQsXG4gICAgMTUsXG4gICAgMjcsXG4gICAgMjgsXG4gICAgMixcbiAgICA0LFxuICAgIDcsXG4gICAgMTMsXG4gICAgMTYsXG4gICAgMjYsXG4gICAgMjksXG4gICAgNDIsXG4gICAgMyxcbiAgICA4LFxuICAgIDEyLFxuICAgIDE3LFxuICAgIDI1LFxuICAgIDMwLFxuICAgIDQxLFxuICAgIDQzLFxuICAgIDksXG4gICAgMTEsXG4gICAgMTgsXG4gICAgMjQsXG4gICAgMzEsXG4gICAgNDAsXG4gICAgNDQsXG4gICAgNTMsXG4gICAgMTAsXG4gICAgMTksXG4gICAgMjMsXG4gICAgMzIsXG4gICAgMzksXG4gICAgNDUsXG4gICAgNTIsXG4gICAgNTQsXG4gICAgMjAsXG4gICAgMjIsXG4gICAgMzMsXG4gICAgMzgsXG4gICAgNDYsXG4gICAgNTEsXG4gICAgNTUsXG4gICAgNjAsXG4gICAgMjEsXG4gICAgMzQsXG4gICAgMzcsXG4gICAgNDcsXG4gICAgNTAsXG4gICAgNTYsXG4gICAgNTksXG4gICAgNjEsXG4gICAgMzUsXG4gICAgMzYsXG4gICAgNDgsXG4gICAgNDksXG4gICAgNTcsXG4gICAgNTgsXG4gICAgNjIsXG4gICAgNjNcbiAgXTtcbiAgc3RhdGljIE1BWF9IVUZGTUFOX1NVQlRSRUUgPSA1MDtcbiAgc3RhdGljIE1TQiA9IDIxNDc0ODM2NDg7XG4gIHN0YXRpYyBSRVNUQVJUX01BUktFUl9CRUdJTiA9IDY1NDg4O1xuICBzdGF0aWMgUkVTVEFSVF9NQVJLRVJfRU5EID0gNjU0OTU7XG4gIGJ1ZmZlciA9IG51bGw7XG4gIHN0cmVhbSA9IG51bGw7XG4gIGZyYW1lID0gbmV3IEZyYW1lSGVhZGVyKCk7XG4gIGh1ZmZUYWJsZSA9IG5ldyBIdWZmbWFuVGFibGUoKTtcbiAgcXVhbnRUYWJsZSA9IG5ldyBRdWFudGl6YXRpb25UYWJsZSgpO1xuICBzY2FuID0gbmV3IFNjYW5IZWFkZXIoKTtcbiAgRFUgPSBjcmVhdGVBcnJheSgxMCwgNCwgNjQpO1xuICAvLyBhdCBtb3N0IDEwIGRhdGEgdW5pdHMgaW4gYSBNQ1UsIGF0IG1vc3QgNCBkYXRhIHVuaXRzIGluIG9uZSBjb21wb25lbnRcbiAgSHVmZlRhYiA9IGNyZWF0ZUFycmF5KDQsIDIsIDUwICogMjU2KTtcbiAgSURDVF9Tb3VyY2UgPSBbXTtcbiAgbkJsb2NrID0gW107XG4gIC8vIG51bWJlciBvZiBibG9ja3MgaW4gdGhlIGktdGggQ29tcCBpbiBhIHNjYW5cbiAgYWNUYWIgPSBjcmVhdGVBcnJheSgxMCwgMSk7XG4gIC8vIGFjIEh1ZmZUYWIgZm9yIHRoZSBpLXRoIENvbXAgaW4gYSBzY2FuXG4gIGRjVGFiID0gY3JlYXRlQXJyYXkoMTAsIDEpO1xuICAvLyBkYyBIdWZmVGFiIGZvciB0aGUgaS10aCBDb21wIGluIGEgc2NhblxuICBxVGFiID0gY3JlYXRlQXJyYXkoMTAsIDEpO1xuICAvLyBxdWFudGl6YXRpb24gdGFibGUgZm9yIHRoZSBpLXRoIENvbXAgaW4gYSBzY2FuXG4gIG1hcmtlciA9IDA7XG4gIG1hcmtlckluZGV4ID0gMDtcbiAgbnVtQ29tcCA9IDA7XG4gIHJlc3RhcnRJbnRlcnZhbCA9IDA7XG4gIHNlbGVjdGlvbiA9IDA7XG4gIHhEaW0gPSAwO1xuICB5RGltID0gMDtcbiAgeExvYyA9IDA7XG4gIHlMb2MgPSAwO1xuICBvdXRwdXREYXRhID0gbnVsbDtcbiAgcmVzdGFydGluZyA9IGZhbHNlO1xuICBtYXNrID0gMDtcbiAgbnVtQnl0ZXMgPSAwO1xuICBwcmVjaXNpb24gPSB2b2lkIDA7XG4gIGNvbXBvbmVudHMgPSBbXTtcbiAgZ2V0dGVyID0gbnVsbDtcbiAgc2V0dGVyID0gbnVsbDtcbiAgb3V0cHV0ID0gbnVsbDtcbiAgc2VsZWN0b3IgPSBudWxsO1xuICAvKipcbiAgICogVGhlIERlY29kZXIgY29uc3RydWN0b3IuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBudW1CeXRlcyAtIG51bWJlciBvZiBieXRlcyBwZXIgY29tcG9uZW50XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJ1ZmZlciwgbnVtQnl0ZXMpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciA/PyBudWxsO1xuICAgIHRoaXMubnVtQnl0ZXMgPSBudW1CeXRlcyA/PyAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlY29tcHJlc3NlZCBkYXRhLlxuICAgKi9cbiAgZGVjb21wcmVzcyhidWZmZXIsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5kZWNvZGUoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG4gIH1cbiAgZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG51bUJ5dGVzKSB7XG4gICAgbGV0IHNjYW5OdW0gPSAwO1xuICAgIGNvbnN0IHByZWQgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgY29tcE47XG4gICAgY29uc3QgdGVtcCA9IFtdO1xuICAgIGNvbnN0IGluZGV4ID0gW107XG4gICAgbGV0IG1jdU51bTtcbiAgICBpZiAoYnVmZmVyKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKG51bUJ5dGVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMubnVtQnl0ZXMgPSBudW1CeXRlcztcbiAgICB9XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgRGF0YVN0cmVhbSh0aGlzLmJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnhMb2MgPSAwO1xuICAgIHRoaXMueUxvYyA9IDA7XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgIGlmIChjdXJyZW50ICE9PSA2NTQ5Nikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgSlBFRyBmaWxlXCIpO1xuICAgIH1cbiAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbiAgICB3aGlsZSAoY3VycmVudCA+PiA0ICE9PSA0MDkyIHx8IGN1cnJlbnQgPT09IDY1NDc2KSB7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnQpIHtcbiAgICAgICAgY2FzZSA2NTQ3NjpcbiAgICAgICAgICB0aGlzLmh1ZmZUYWJsZS5yZWFkKHRoaXMuc3RyZWFtLCB0aGlzLkh1ZmZUYWIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY1NDg0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW0gZG9lc24ndCBzdXBwb3J0IGFyaXRobWV0aWMgY29kaW5nLiAoZm9ybWF0IHRocm93IG5ldyBJT0V4Y2VwdGlvbilcIik7XG4gICAgICAgIGNhc2UgNjU0OTk6XG4gICAgICAgICAgdGhpcy5xdWFudFRhYmxlLnJlYWQodGhpcy5zdHJlYW0sIF9EZWNvZGVyLlRBQkxFKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2NTUwMTpcbiAgICAgICAgICB0aGlzLnJlc3RhcnRJbnRlcnZhbCA9IHRoaXMucmVhZE51bWJlcigpID8/IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjU1MDQ6XG4gICAgICAgIGNhc2UgNjU1MDU6XG4gICAgICAgIGNhc2UgNjU1MDY6XG4gICAgICAgIGNhc2UgNjU1MDc6XG4gICAgICAgIGNhc2UgNjU1MDg6XG4gICAgICAgIGNhc2UgNjU1MDk6XG4gICAgICAgIGNhc2UgNjU1MTA6XG4gICAgICAgIGNhc2UgNjU1MTE6XG4gICAgICAgIGNhc2UgNjU1MTI6XG4gICAgICAgIGNhc2UgNjU1MTM6XG4gICAgICAgIGNhc2UgNjU1MTQ6XG4gICAgICAgIGNhc2UgNjU1MTU6XG4gICAgICAgIGNhc2UgNjU1MTY6XG4gICAgICAgIGNhc2UgNjU1MTc6XG4gICAgICAgIGNhc2UgNjU1MTg6XG4gICAgICAgIGNhc2UgNjU1MTk6XG4gICAgICAgICAgdGhpcy5yZWFkQXBwKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjU1MzQ6XG4gICAgICAgICAgdGhpcy5yZWFkQ29tbWVudCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChjdXJyZW50ID4+IDggIT09IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGZvcm1hdCB0aHJvdyBuZXcgSU9FeGNlcHRpb24hIChkZWNvZGUpXCIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudCA8IDY1NDcyIHx8IGN1cnJlbnQgPiA2NTQ3OSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1I6IGNvdWxkIG5vdCBoYW5kbGUgYXJpdGhtZXRpYyBjb2RlIVwiKTtcbiAgICB9XG4gICAgdGhpcy5mcmFtZS5yZWFkKHRoaXMuc3RyZWFtKTtcbiAgICBjdXJyZW50ID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbiAgICBkbyB7XG4gICAgICB3aGlsZSAoY3VycmVudCAhPT0gNjU0OTgpIHtcbiAgICAgICAgc3dpdGNoIChjdXJyZW50KSB7XG4gICAgICAgICAgY2FzZSA2NTQ3NjpcbiAgICAgICAgICAgIHRoaXMuaHVmZlRhYmxlLnJlYWQodGhpcy5zdHJlYW0sIHRoaXMuSHVmZlRhYik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY1NDg0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbSBkb2Vzbid0IHN1cHBvcnQgYXJpdGhtZXRpYyBjb2RpbmcuIChmb3JtYXQgdGhyb3cgbmV3IElPRXhjZXB0aW9uKVwiKTtcbiAgICAgICAgICBjYXNlIDY1NDk5OlxuICAgICAgICAgICAgdGhpcy5xdWFudFRhYmxlLnJlYWQodGhpcy5zdHJlYW0sIF9EZWNvZGVyLlRBQkxFKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjU1MDE6XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRJbnRlcnZhbCA9IHRoaXMucmVhZE51bWJlcigpID8/IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY1NTA0OlxuICAgICAgICAgIGNhc2UgNjU1MDU6XG4gICAgICAgICAgY2FzZSA2NTUwNjpcbiAgICAgICAgICBjYXNlIDY1NTA3OlxuICAgICAgICAgIGNhc2UgNjU1MDg6XG4gICAgICAgICAgY2FzZSA2NTUwOTpcbiAgICAgICAgICBjYXNlIDY1NTEwOlxuICAgICAgICAgIGNhc2UgNjU1MTE6XG4gICAgICAgICAgY2FzZSA2NTUxMjpcbiAgICAgICAgICBjYXNlIDY1NTEzOlxuICAgICAgICAgIGNhc2UgNjU1MTQ6XG4gICAgICAgICAgY2FzZSA2NTUxNTpcbiAgICAgICAgICBjYXNlIDY1NTE2OlxuICAgICAgICAgIGNhc2UgNjU1MTc6XG4gICAgICAgICAgY2FzZSA2NTUxODpcbiAgICAgICAgICBjYXNlIDY1NTE5OlxuICAgICAgICAgICAgdGhpcy5yZWFkQXBwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY1NTM0OlxuICAgICAgICAgICAgdGhpcy5yZWFkQ29tbWVudCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID4+IDggIT09IDI1NSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUjogZm9ybWF0IHRocm93IG5ldyBJT0V4Y2VwdGlvbiEgKFBhcnNlci5kZWNvZGUpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVjaXNpb24gPSB0aGlzLmZyYW1lLnByZWNpc2lvbjtcbiAgICAgIHRoaXMuY29tcG9uZW50cyA9IHRoaXMuZnJhbWUuY29tcG9uZW50cztcbiAgICAgIGlmICghdGhpcy5udW1CeXRlcykge1xuICAgICAgICB0aGlzLm51bUJ5dGVzID0gTWF0aC5yb3VuZChNYXRoLmNlaWwodGhpcy5wcmVjaXNpb24gLyA4KSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5udW1CeXRlcyA9PT0gMSkge1xuICAgICAgICB0aGlzLm1hc2sgPSAyNTU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hc2sgPSA2NTUzNTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nhbi5yZWFkKHRoaXMuc3RyZWFtKTtcbiAgICAgIHRoaXMubnVtQ29tcCA9IHRoaXMuc2Nhbi5udW1Db21wO1xuICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnNjYW4uc2VsZWN0aW9uO1xuICAgICAgaWYgKHRoaXMubnVtQnl0ZXMgPT09IDEpIHtcbiAgICAgICAgaWYgKHRoaXMubnVtQ29tcCA9PT0gMykge1xuICAgICAgICAgIHRoaXMuZ2V0dGVyID0gdGhpcy5nZXRWYWx1ZVJHQjtcbiAgICAgICAgICB0aGlzLnNldHRlciA9IHRoaXMuc2V0VmFsdWVSR0I7XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dFJHQjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmdldHRlciA9IHRoaXMuZ2V0VmFsdWU4O1xuICAgICAgICAgIHRoaXMuc2V0dGVyID0gdGhpcy5zZXRWYWx1ZTg7XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dFNpbmdsZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXR0ZXIgPSB0aGlzLmdldFZhbHVlODtcbiAgICAgICAgdGhpcy5zZXR0ZXIgPSB0aGlzLnNldFZhbHVlODtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dFNpbmdsZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3QzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0NDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdDU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3Q2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHRoaXMuc2VsZWN0NztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gdGhpcy5zZWxlY3QxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubnVtQ29tcDsgaSArPSAxKSB7XG4gICAgICAgIGNvbXBOID0gdGhpcy5zY2FuLmNvbXBvbmVudHNbaV0uc2NhbkNvbXBTZWw7XG4gICAgICAgIHRoaXMucVRhYltpXSA9IHRoaXMucXVhbnRUYWJsZS5xdWFudFRhYmxlc1t0aGlzLmNvbXBvbmVudHNbY29tcE5dLnF1YW50VGFibGVTZWxdO1xuICAgICAgICB0aGlzLm5CbG9ja1tpXSA9IHRoaXMuY29tcG9uZW50c1tjb21wTl0udlNhbXAgKiB0aGlzLmNvbXBvbmVudHNbY29tcE5dLmhTYW1wO1xuICAgICAgICB0aGlzLmRjVGFiW2ldID0gdGhpcy5IdWZmVGFiW3RoaXMuc2Nhbi5jb21wb25lbnRzW2ldLmRjVGFiU2VsXVswXTtcbiAgICAgICAgdGhpcy5hY1RhYltpXSA9IHRoaXMuSHVmZlRhYlt0aGlzLnNjYW4uY29tcG9uZW50c1tpXS5hY1RhYlNlbF1bMV07XG4gICAgICB9XG4gICAgICB0aGlzLnhEaW0gPSB0aGlzLmZyYW1lLmRpbVg7XG4gICAgICB0aGlzLnlEaW0gPSB0aGlzLmZyYW1lLmRpbVk7XG4gICAgICBpZiAodGhpcy5udW1CeXRlcyA9PT0gMSkge1xuICAgICAgICB0aGlzLm91dHB1dERhdGEgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIodGhpcy54RGltICogdGhpcy55RGltICogdGhpcy5udW1CeXRlcyAqIHRoaXMubnVtQ29tcCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhID0gbmV3IFVpbnQxNkFycmF5KG5ldyBBcnJheUJ1ZmZlcih0aGlzLnhEaW0gKiB0aGlzLnlEaW0gKiB0aGlzLm51bUJ5dGVzICogdGhpcy5udW1Db21wKSk7XG4gICAgICB9XG4gICAgICBzY2FuTnVtICs9IDE7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB0ZW1wWzBdID0gMDtcbiAgICAgICAgaW5kZXhbMF0gPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkgKz0gMSkge1xuICAgICAgICAgIHByZWRbaV0gPSAxIDw8IHRoaXMucHJlY2lzaW9uIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0YXJ0SW50ZXJ2YWwgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gdGhpcy5kZWNvZGVVbml0KHByZWQsIHRlbXAsIGluZGV4KTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudCA9PT0gMCAmJiB0aGlzLnhMb2MgPCB0aGlzLnhEaW0gJiYgdGhpcy55TG9jIDwgdGhpcy55RGltKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dChwcmVkKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmRlY29kZVVuaXQocHJlZCwgdGVtcCwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKG1jdU51bSA9IDA7IG1jdU51bSA8IHRoaXMucmVzdGFydEludGVydmFsOyBtY3VOdW0gKz0gMSkge1xuICAgICAgICAgIHRoaXMucmVzdGFydGluZyA9IG1jdU51bSA9PT0gMDtcbiAgICAgICAgICBjdXJyZW50ID0gdGhpcy5kZWNvZGVVbml0KHByZWQsIHRlbXAsIGluZGV4KTtcbiAgICAgICAgICB0aGlzLm91dHB1dChwcmVkKTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWFya2VySW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSA2NTI4MCB8IHRoaXMubWFya2VyO1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnN0cmVhbS5nZXQxNigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjdXJyZW50ID49IF9EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0JFR0lOICYmIGN1cnJlbnQgPD0gX0RlY29kZXIuUkVTVEFSVF9NQVJLRVJfRU5EKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gNjU1MDAgJiYgc2Nhbk51bSA9PT0gMSkge1xuICAgICAgICB0aGlzLnJlYWROdW1iZXIoKTtcbiAgICAgICAgY3VycmVudCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY3VycmVudCAhPT0gNjU0OTcgJiYgdGhpcy54TG9jIDwgdGhpcy54RGltICYmIHRoaXMueUxvYyA8IHRoaXMueURpbSAmJiBzY2FuTnVtID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXREYXRhO1xuICB9XG4gIGRlY29kZVVuaXQocHJldiwgdGVtcCwgaW5kZXgpIHtcbiAgICBpZiAodGhpcy5udW1Db21wID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVTaW5nbGUocHJldiwgdGVtcCwgaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5udW1Db21wID09PSAzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVSR0IocHJldiwgdGVtcCwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHNlbGVjdDEoY29tcE9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWChjb21wT2Zmc2V0KTtcbiAgfVxuICBzZWxlY3QyKGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCk7XG4gIH1cbiAgc2VsZWN0Myhjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNYWShjb21wT2Zmc2V0KTtcbiAgfVxuICBzZWxlY3Q0KGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgKyB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KSAtIHRoaXMuZ2V0UHJldmlvdXNYWShjb21wT2Zmc2V0KTtcbiAgfVxuICBzZWxlY3Q1KGNvbXBPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgKyAodGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCkgLSB0aGlzLmdldFByZXZpb3VzWFkoY29tcE9mZnNldCkgPj4gMSk7XG4gIH1cbiAgc2VsZWN0Nihjb21wT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpICsgKHRoaXMuZ2V0UHJldmlvdXNYKGNvbXBPZmZzZXQpIC0gdGhpcy5nZXRQcmV2aW91c1hZKGNvbXBPZmZzZXQpID4+IDEpO1xuICB9XG4gIHNlbGVjdDcoY29tcE9mZnNldCkge1xuICAgIHJldHVybiAodGhpcy5nZXRQcmV2aW91c1goY29tcE9mZnNldCkgKyB0aGlzLmdldFByZXZpb3VzWShjb21wT2Zmc2V0KSkgLyAyO1xuICB9XG4gIGRlY29kZVJHQihwcmV2LCB0ZW1wLCBpbmRleCkge1xuICAgIGlmICh0aGlzLnNlbGVjdG9yID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVjb2RlIGhhc24ndCBydW4geWV0XCIpO1xuICAgIGxldCBhY3RhYiwgZGN0YWIsIHF0YWIsIGN0ckMsIGksIGssIGo7XG4gICAgcHJldlswXSA9IHRoaXMuc2VsZWN0b3IoMCk7XG4gICAgcHJldlsxXSA9IHRoaXMuc2VsZWN0b3IoMSk7XG4gICAgcHJldlsyXSA9IHRoaXMuc2VsZWN0b3IoMik7XG4gICAgZm9yIChjdHJDID0gMDsgY3RyQyA8IHRoaXMubnVtQ29tcDsgY3RyQyArPSAxKSB7XG4gICAgICBxdGFiID0gdGhpcy5xVGFiW2N0ckNdO1xuICAgICAgYWN0YWIgPSB0aGlzLmFjVGFiW2N0ckNdO1xuICAgICAgZGN0YWIgPSB0aGlzLmRjVGFiW2N0ckNdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubkJsb2NrW2N0ckNdOyBpICs9IDEpIHtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IHRoaXMuSURDVF9Tb3VyY2UubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICB0aGlzLklEQ1RfU291cmNlW2tdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldEh1ZmZtYW5WYWx1ZShkY3RhYiwgdGVtcCwgaW5kZXgpO1xuICAgICAgICBpZiAodmFsdWUgPj0gNjUyODApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldltjdHJDXSA9IHRoaXMuSURDVF9Tb3VyY2VbMF0gPSBwcmV2W2N0ckNdICsgdGhpcy5nZXRuKGluZGV4LCB2YWx1ZSwgdGVtcCwgaW5kZXgpO1xuICAgICAgICB0aGlzLklEQ1RfU291cmNlWzBdICo9IHF0YWJbMF07XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCA2NDsgaiArPSAxKSB7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEh1ZmZtYW5WYWx1ZShhY3RhYiwgdGVtcCwgaW5kZXgpO1xuICAgICAgICAgIGlmICh2YWx1ZSA+PSA2NTI4MCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBqICs9IHZhbHVlID4+IDQ7XG4gICAgICAgICAgaWYgKCh2YWx1ZSAmIDE1KSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4+IDQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuSURDVF9Tb3VyY2VbX0RlY29kZXIuSURDVF9QW2pdXSA9IHRoaXMuZ2V0bihpbmRleCwgdmFsdWUgJiAxNSwgdGVtcCwgaW5kZXgpICogcXRhYltqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZGVjb2RlU2luZ2xlKHByZXYsIHRlbXAsIGluZGV4KSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0b3IgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWNvZGUgaGFzbid0IHJ1biB5ZXRcIik7XG4gICAgbGV0IHZhbHVlLCBpLCBuLCBuUmVzdGFydDtcbiAgICBpZiAodGhpcy5yZXN0YXJ0aW5nKSB7XG4gICAgICB0aGlzLnJlc3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgIHByZXZbMF0gPSAxIDw8IHRoaXMuZnJhbWUucHJlY2lzaW9uIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldlswXSA9IHRoaXMuc2VsZWN0b3IoKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubkJsb2NrWzBdOyBpICs9IDEpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXRIdWZmbWFuVmFsdWUodGhpcy5kY1RhYlswXSwgdGVtcCwgaW5kZXgpO1xuICAgICAgaWYgKHZhbHVlID49IDY1MjgwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIG4gPSB0aGlzLmdldG4ocHJldiwgdmFsdWUsIHRlbXAsIGluZGV4KTtcbiAgICAgIG5SZXN0YXJ0ID0gbiA+PiA4O1xuICAgICAgaWYgKG5SZXN0YXJ0ID49IF9EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0JFR0lOICYmIG5SZXN0YXJ0IDw9IF9EZWNvZGVyLlJFU1RBUlRfTUFSS0VSX0VORCkge1xuICAgICAgICByZXR1cm4gblJlc3RhcnQ7XG4gICAgICB9XG4gICAgICBwcmV2WzBdICs9IG47XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIC8vXHRIdWZmbWFuIHRhYmxlIGZvciBmYXN0IHNlYXJjaDogKEh1ZmZUYWIpIDgtYml0IExvb2sgdXAgdGFibGUgMi1sYXllciBzZWFyY2ggYXJjaGl0ZWN0dXJlLCAxc3QtbGF5ZXIgcmVwcmVzZW50IDI1NiBub2RlICg4IGJpdHMpIGlmIGNvZGV3b3JkLWxlbmd0aCA+IDhcbiAgLy9cdGJpdHMsIHRoZW4gdGhlIGVudHJ5IG9mIDFzdC1sYXllciA9ICgjIG9mIDJuZC1sYXllciB0YWJsZSkgfCBNU0IgYW5kIGl0IGlzIHN0b3JlZCBpbiB0aGUgMm5kLWxheWVyIFNpemUgb2YgdGFibGVzIGluIGVhY2ggbGF5ZXIgYXJlIDI1Ni5cbiAgLy9cdEh1ZmZUYWJbKl1bKl1bMC0yNTZdIGlzIGFsd2F5cyB0aGUgb25seSAxc3QtbGF5ZXIgdGFibGUuXG4gIC8vXG4gIC8vXHRBbiBlbnRyeSBjYW4gYmU6ICgxKSAoIyBvZiAybmQtbGF5ZXIgdGFibGUpIHwgTVNCICwgZm9yIGNvZGUgbGVuZ3RoID4gOCBpbiAxc3QtbGF5ZXIgKDIpIChDb2RlIGxlbmd0aCkgPDwgOCB8IEh1ZmZWYWxcbiAgLy9cbiAgLy9cdEh1ZmZtYW5WYWx1ZSh0YWJsZSAgIEh1ZmZUYWJbeF1beV0gKGV4KSBIdWZmbWFuVmFsdWUoSHVmZlRhYlsxXVswXSwuLi4pXG4gIC8vXHQgICAgICAgICAgICAgICAgKTpcbiAgLy9cdCAgICByZXR1cm46IEh1ZmZtYW4gVmFsdWUgb2YgdGFibGVcbiAgLy9cdCAgICAgICAgICAgIDB4RkY/PyBpZiBpdCByZWNlaXZlcyBhIE1BUktFUlxuICAvL1x0ICAgIFBhcmFtZXRlcjogIHRhYmxlICAgSHVmZlRhYlt4XVt5XSAoZXgpIEh1ZmZtYW5WYWx1ZShIdWZmVGFiWzFdWzBdLC4uLilcbiAgLy9cdCAgICAgICAgICAgICAgICB0ZW1wICAgIHRlbXAgc3RvcmFnZSBmb3IgcmVtYWluZGVkIGJpdHNcbiAgLy9cdCAgICAgICAgICAgICAgICBpbmRleCAgIGluZGV4IHRvIGJpdCBvZiB0ZW1wXG4gIC8vXHQgICAgICAgICAgICAgICAgaW4gICAgICBGSUxFIHBvaW50ZXJcbiAgLy9cdCAgICBFZmZlY3Q6XG4gIC8vXHQgICAgICAgIHRlbXAgIHN0b3JlIG5ldyByZW1haW5kZWQgYml0c1xuICAvL1x0ICAgICAgICBpbmRleCBjaGFuZ2UgdG8gbmV3IGluZGV4XG4gIC8vXHQgICAgICAgIGluICAgIGNoYW5nZSB0byBuZXcgcG9zaXRpb25cbiAgLy9cdCAgICBOT1RFOlxuICAvL1x0ICAgICAgSW5pdGlhbCBieSAgIHRlbXA9MDsgaW5kZXg9MDtcbiAgLy9cdCAgICBOT1RFOiAoZXhwbGFpbiB0ZW1wIGFuZCBpbmRleClcbiAgLy9cdCAgICAgIHRlbXA6IGlzIGFsd2F5cyBpbiB0aGUgZm9ybSBhdCBjYWxsaW5nIHRpbWUgb3IgcmV0dXJuaW5nIHRpbWVcbiAgLy9cdCAgICAgICB8ICBieXRlIDQgIHwgIGJ5dGUgMyAgfCAgYnl0ZSAyICB8ICBieXRlIDEgIHxcbiAgLy9cdCAgICAgICB8ICAgICAwICAgIHwgICAgIDAgICAgfCAwMDAwMDAwMCB8IDAwMDAwPz8/IHwgIGlmIG5vdCBhIE1BUktFUlxuICAvL1x0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeaW5kZXg9MyAoZnJvbSAwIHRvIDE1KVxuICAvL1x0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMjFcbiAgLy9cdCAgICBOT1RFIChtYXJrZXIgYW5kIG1hcmtlcl9pbmRleCk6XG4gIC8vXHQgICAgICBJZiBnZXQgYSBNQVJLRVIgZnJvbSAnaW4nLCBtYXJrZXI9dGhlIGxvdy1ieXRlIG9mIHRoZSBNQVJLRVJcbiAgLy9cdCAgICAgICAgYW5kIG1hcmtlcl9pbmRleD05XG4gIC8vXHQgICAgICBJZiBtYXJrZXJfaW5kZXg9OSB0aGVuIGluZGV4IGlzIGFsd2F5cyA+IDgsIG9yIEh1ZmZtYW5WYWx1ZSgpXG4gIC8vXHQgICAgICAgIHdpbGwgbm90IGJlIGNhbGxlZFxuICBnZXRIdWZmbWFuVmFsdWUodGFibGUsIHRlbXAsIGluZGV4KSB7XG4gICAgbGV0IGNvZGUsIGlucHV0O1xuICAgIGNvbnN0IG1hc2sgPSA2NTUzNTtcbiAgICBpZiAoIXRoaXMuc3RyZWFtKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RyZWFtIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICBpZiAoaW5kZXhbMF0gPCA4KSB7XG4gICAgICB0ZW1wWzBdIDw8PSA4O1xuICAgICAgaW5wdXQgPSB0aGlzLnN0cmVhbS5nZXQ4KCk7XG4gICAgICBpZiAoaW5wdXQgPT09IDI1NSkge1xuICAgICAgICB0aGlzLm1hcmtlciA9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgICAgaWYgKHRoaXMubWFya2VyICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBbMF0gfD0gaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4WzBdIC09IDg7XG4gICAgfVxuICAgIGNvZGUgPSB0YWJsZVt0ZW1wWzBdID4+IGluZGV4WzBdXTtcbiAgICBpZiAoKGNvZGUgJiBfRGVjb2Rlci5NU0IpICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5tYXJrZXJJbmRleCAhPT0gMCkge1xuICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIDY1MjgwIHwgdGhpcy5tYXJrZXI7XG4gICAgICB9XG4gICAgICB0ZW1wWzBdICY9IG1hc2sgPj4gMTYgLSBpbmRleFswXTtcbiAgICAgIHRlbXBbMF0gPDw9IDg7XG4gICAgICBpbnB1dCA9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgIGlmIChpbnB1dCA9PT0gMjU1KSB7XG4gICAgICAgIHRoaXMubWFya2VyID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICBpZiAodGhpcy5tYXJrZXIgIT09IDApIHtcbiAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gOTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcFswXSB8PSBpbnB1dDtcbiAgICAgIGNvZGUgPSB0YWJsZVsoY29kZSAmIDI1NSkgKiAyNTYgKyAodGVtcFswXSA+PiBpbmRleFswXSldO1xuICAgICAgaW5kZXhbMF0gKz0gODtcbiAgICB9XG4gICAgaW5kZXhbMF0gKz0gOCAtIChjb2RlID4+IDgpO1xuICAgIGlmIChpbmRleFswXSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4PVwiICsgaW5kZXhbMF0gKyBcIiB0ZW1wPVwiICsgdGVtcFswXSArIFwiIGNvZGU9XCIgKyBjb2RlICsgXCIgaW4gSHVmZm1hblZhbHVlKClcIik7XG4gICAgfVxuICAgIGlmIChpbmRleFswXSA8IHRoaXMubWFya2VySW5kZXgpIHtcbiAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgcmV0dXJuIDY1MjgwIHwgdGhpcy5tYXJrZXI7XG4gICAgfVxuICAgIHRlbXBbMF0gJj0gbWFzayA+PiAxNiAtIGluZGV4WzBdO1xuICAgIHJldHVybiBjb2RlICYgMjU1O1xuICB9XG4gIGdldG4oUFJFRCwgbiwgdGVtcCwgaW5kZXgpIHtcbiAgICBsZXQgcmVzdWx0LCBpbnB1dDtcbiAgICBjb25zdCBvbmUgPSAxO1xuICAgIGNvbnN0IG5fb25lID0gLTE7XG4gICAgY29uc3QgbWFzayA9IDY1NTM1O1xuICAgIGlmICh0aGlzLnN0cmVhbSA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInN0cmVhbSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAobiA9PT0gMTYpIHtcbiAgICAgIGlmIChQUkVEWzBdID49IDApIHtcbiAgICAgICAgcmV0dXJuIC0zMjc2ODtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAzMjc2ODtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5kZXhbMF0gLT0gbjtcbiAgICBpZiAoaW5kZXhbMF0gPj0gMCkge1xuICAgICAgaWYgKGluZGV4WzBdIDwgdGhpcy5tYXJrZXJJbmRleCAmJiAhdGhpcy5pc0xhc3RQaXhlbCgpKSB7XG4gICAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gKDY1MjgwIHwgdGhpcy5tYXJrZXIpIDw8IDg7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB0ZW1wWzBdID4+IGluZGV4WzBdO1xuICAgICAgdGVtcFswXSAmPSBtYXNrID4+IDE2IC0gaW5kZXhbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBbMF0gPDw9IDg7XG4gICAgICBpbnB1dCA9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgIGlmIChpbnB1dCA9PT0gMjU1KSB7XG4gICAgICAgIHRoaXMubWFya2VyID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICBpZiAodGhpcy5tYXJrZXIgIT09IDApIHtcbiAgICAgICAgICB0aGlzLm1hcmtlckluZGV4ID0gOTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcFswXSB8PSBpbnB1dDtcbiAgICAgIGluZGV4WzBdICs9IDg7XG4gICAgICBpZiAoaW5kZXhbMF0gPCAwKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtlckluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDA7XG4gICAgICAgICAgcmV0dXJuICg2NTI4MCB8IHRoaXMubWFya2VyKSA8PCA4O1xuICAgICAgICB9XG4gICAgICAgIHRlbXBbMF0gPDw9IDg7XG4gICAgICAgIGlucHV0ID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IDI1NSkge1xuICAgICAgICAgIHRoaXMubWFya2VyID0gdGhpcy5zdHJlYW0uZ2V0OCgpO1xuICAgICAgICAgIGlmICh0aGlzLm1hcmtlciAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJJbmRleCA9IDk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRlbXBbMF0gfD0gaW5wdXQ7XG4gICAgICAgIGluZGV4WzBdICs9IDg7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXhbMF0gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4PVwiICsgaW5kZXhbMF0gKyBcIiBpbiBnZXRuKClcIik7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXhbMF0gPCB0aGlzLm1hcmtlckluZGV4KSB7XG4gICAgICAgIHRoaXMubWFya2VySW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gKDY1MjgwIHwgdGhpcy5tYXJrZXIpIDw8IDg7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB0ZW1wWzBdID4+IGluZGV4WzBdO1xuICAgICAgdGVtcFswXSAmPSBtYXNrID4+IDE2IC0gaW5kZXhbMF07XG4gICAgfVxuICAgIGlmIChyZXN1bHQgPCBvbmUgPDwgbiAtIDEpIHtcbiAgICAgIHJlc3VsdCArPSAobl9vbmUgPDwgbikgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFByZXZpb3VzWChjb21wT2Zmc2V0ID0gMCkge1xuICAgIGlmICh0aGlzLmdldHRlciA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRlY29kZSBoYXNuJ3QgcnVuIHlldFwiKTtcbiAgICBpZiAodGhpcy54TG9jID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKHRoaXMueUxvYyAqIHRoaXMueERpbSArIHRoaXMueExvYyAtIDEsIGNvbXBPZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy55TG9jID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJldmlvdXNZKGNvbXBPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMSA8PCB0aGlzLmZyYW1lLnByZWNpc2lvbiAtIDE7XG4gICAgfVxuICB9XG4gIGdldFByZXZpb3VzWFkoY29tcE9mZnNldCA9IDApIHtcbiAgICBpZiAodGhpcy5nZXR0ZXIgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWNvZGUgaGFzbid0IHJ1biB5ZXRcIik7XG4gICAgaWYgKHRoaXMueExvYyA+IDAgJiYgdGhpcy55TG9jID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKCh0aGlzLnlMb2MgLSAxKSAqIHRoaXMueERpbSArIHRoaXMueExvYyAtIDEsIGNvbXBPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQcmV2aW91c1koY29tcE9mZnNldCk7XG4gICAgfVxuICB9XG4gIGdldFByZXZpb3VzWShjb21wT2Zmc2V0ID0gMCkge1xuICAgIGlmICh0aGlzLmdldHRlciA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRlY29kZSBoYXNuJ3QgcnVuIHlldFwiKTtcbiAgICBpZiAodGhpcy55TG9jID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKCh0aGlzLnlMb2MgLSAxKSAqIHRoaXMueERpbSArIHRoaXMueExvYywgY29tcE9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFByZXZpb3VzWChjb21wT2Zmc2V0KTtcbiAgICB9XG4gIH1cbiAgaXNMYXN0UGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMueExvYyA9PT0gdGhpcy54RGltIC0gMSAmJiB0aGlzLnlMb2MgPT09IHRoaXMueURpbSAtIDE7XG4gIH1cbiAgb3V0cHV0U2luZ2xlKFBSRUQpIHtcbiAgICBpZiAodGhpcy5zZXR0ZXIgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWNvZGUgaGFzbid0IHJ1biB5ZXRcIik7XG4gICAgaWYgKHRoaXMueExvYyA8IHRoaXMueERpbSAmJiB0aGlzLnlMb2MgPCB0aGlzLnlEaW0pIHtcbiAgICAgIHRoaXMuc2V0dGVyKHRoaXMueUxvYyAqIHRoaXMueERpbSArIHRoaXMueExvYywgdGhpcy5tYXNrICYgUFJFRFswXSk7XG4gICAgICB0aGlzLnhMb2MgKz0gMTtcbiAgICAgIGlmICh0aGlzLnhMb2MgPj0gdGhpcy54RGltKSB7XG4gICAgICAgIHRoaXMueUxvYyArPSAxO1xuICAgICAgICB0aGlzLnhMb2MgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvdXRwdXRSR0IoUFJFRCkge1xuICAgIGlmICh0aGlzLnNldHRlciA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRlY29kZSBoYXNuJ3QgcnVuIHlldFwiKTtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnlMb2MgKiB0aGlzLnhEaW0gKyB0aGlzLnhMb2M7XG4gICAgaWYgKHRoaXMueExvYyA8IHRoaXMueERpbSAmJiB0aGlzLnlMb2MgPCB0aGlzLnlEaW0pIHtcbiAgICAgIHRoaXMuc2V0dGVyKG9mZnNldCwgUFJFRFswXSwgMCk7XG4gICAgICB0aGlzLnNldHRlcihvZmZzZXQsIFBSRURbMV0sIDEpO1xuICAgICAgdGhpcy5zZXR0ZXIob2Zmc2V0LCBQUkVEWzJdLCAyKTtcbiAgICAgIHRoaXMueExvYyArPSAxO1xuICAgICAgaWYgKHRoaXMueExvYyA+PSB0aGlzLnhEaW0pIHtcbiAgICAgICAgdGhpcy55TG9jICs9IDE7XG4gICAgICAgIHRoaXMueExvYyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldFZhbHVlOChpbmRleCwgdmFsKSB7XG4gICAgaWYgKCF0aGlzLm91dHB1dERhdGEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXQgZGF0YSBub3QgcmVhZHlcIik7XG4gICAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgICAgdGhpcy5vdXRwdXREYXRhW2luZGV4XSA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vdXRwdXREYXRhW2luZGV4XSA9ICh2YWwgJiAyNTUpIDw8IDggfCB2YWwgPj4gOCAmIDI1NTtcbiAgICB9XG4gIH1cbiAgZ2V0VmFsdWU4KGluZGV4KSB7XG4gICAgaWYgKHRoaXMub3V0cHV0RGF0YSA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm91dHB1dCBkYXRhIG5vdCByZWFkeVwiKTtcbiAgICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXREYXRhW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy5vdXRwdXREYXRhW2luZGV4XTtcbiAgICAgIHJldHVybiAodmFsICYgMjU1KSA8PCA4IHwgdmFsID4+IDggJiAyNTU7XG4gICAgfVxuICB9XG4gIHNldFZhbHVlUkdCKGluZGV4LCB2YWwsIGNvbXBPZmZzZXQgPSAwKSB7XG4gICAgaWYgKHRoaXMub3V0cHV0RGF0YSA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLm91dHB1dERhdGFbaW5kZXggKiAzICsgY29tcE9mZnNldF0gPSB2YWw7XG4gIH1cbiAgZ2V0VmFsdWVSR0IoaW5kZXgsIGNvbXBPZmZzZXQpIHtcbiAgICBpZiAodGhpcy5vdXRwdXREYXRhID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0IGRhdGEgbm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLm91dHB1dERhdGFbaW5kZXggKiAzICsgY29tcE9mZnNldF07XG4gIH1cbiAgcmVhZEFwcCgpIHtcbiAgICBpZiAodGhpcy5zdHJlYW0gPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcbiAgICB3aGlsZSAoY291bnQgPCBsZW5ndGgpIHtcbiAgICAgIHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cbiAgcmVhZENvbW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuc3RyZWFtID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHNiID0gXCJcIjtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gICAgY291bnQgKz0gMjtcbiAgICB3aGlsZSAoY291bnQgPCBsZW5ndGgpIHtcbiAgICAgIHNiICs9IHRoaXMuc3RyZWFtLmdldDgoKTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBzYjtcbiAgfVxuICByZWFkTnVtYmVyKCkge1xuICAgIGlmICh0aGlzLnN0cmVhbSA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IExkID0gdGhpcy5zdHJlYW0uZ2V0MTYoKTtcbiAgICBpZiAoTGQgIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SOiBEZWZpbmUgbnVtYmVyIGZvcm1hdCB0aHJvdyBuZXcgSU9FeGNlcHRpb24gW0xkIT00XVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtLmdldDE2KCk7XG4gIH1cbn07XG5leHBvcnQge1xuICBDb21wb25lbnRTcGVjLFxuICBEYXRhU3RyZWFtLFxuICBEZWNvZGVyLFxuICBGcmFtZUhlYWRlcixcbiAgSHVmZm1hblRhYmxlLFxuICBRdWFudGl6YXRpb25UYWJsZSxcbiAgU2NhbkNvbXBvbmVudCxcbiAgU2NhbkhlYWRlcixcbiAgdXRpbHNfZXhwb3J0cyBhcyBVdGlsc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvc3NsZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jpeg-lossless-decoder-js/release/lossless.js\n"));

/***/ })

}]);