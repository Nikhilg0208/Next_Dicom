"use client";

import {
  Enums,
  RenderingEngine,
  init as coreInit,
  getEnabledElement,
  getRenderingEngine,
} from "@cornerstonejs/core";
import { init as dicomImageLoaderInit } from "@cornerstonejs/dicom-image-loader";
import {
  SplineROITool,
  StackScrollTool,
  ToolGroupManager,
  addTool,
  annotation,
  Enums as csToolsEnums,
  init as toolsInit,
} from "@cornerstonejs/tools";
import React, { useEffect, useRef, useState } from "react";

import DebugInfo from "./components/DebugInfo";
import FileUploader from "./components/FileUploader";
import Instructions from "./components/Instructions";
import SliceSlider from "./components/SliceSlider";
import Toolbar from "./components/Toolbar";
import Viewport from "./components/Viewport";

import styles from "./styles/DicomViewer.module.css";

const { ViewportType } = Enums;
const { MouseBindings } = csToolsEnums;

function loadAnnotations(
  viewportId,
  renderingEngineId,
  imageId,
  fileName,
  element
) {
  const storageKey = `annotations_${fileName}`;
  const saved = localStorage.getItem(storageKey);

  if (!saved) {
    console.log("No saved annotations found for", fileName);
    return;
  }

  const annotations = JSON.parse(saved);

  // ✅ Remove only annotations for THIS imageId (instead of clearing all)
  const existingAnnotations = annotation.state.getAnnotations(
    "SplineROI",
    element
  );
  existingAnnotations
    .filter((ann) => ann.metadata.referencedImageId === imageId)
    .forEach((ann) => annotation.state.removeAnnotation(ann.annotationUID));

  const toolGroup = ToolGroupManager.getToolGroup("dicomToolGroup");

  annotations.forEach((ann) => {
    // ann.metadata.toolName
    // imageId
    // ann.metadata.FrameOfReferenceUID
    // annotationUID
    // ann.data.handles.points
    const toolInstance = toolGroup.getToolInstance(ann.toolName);

    const originalConfig = toolGroup.getToolConfiguration(
      ann.toolName,
      "spline"
    );
    const splineType = originalConfig?.type || "CARDINAL";
    const splineConfig = toolInstance._getSplineConfig(splineType);
    const SplineClass = splineConfig.Class;
    const splineInstance = new SplineClass();

    // ✅ Build restored annotation object
    const splineAnnotation = {
      annotationUID: ann.annotationUID,
      metadata: {
        referencedImageId: imageId,
        toolName: ann.toolName,
        viewportId,
        renderingEngineId,
        FrameOfReferenceUID: ann.FrameOfReferenceUID,
      },
      data: {
        handles: {
          points: ann.points,
        },
        label: "",
        cachedStats: {},
        spline: {
          type: splineType,
          instance: splineInstance,
        },
        contour: {
          closed: true,
        },
      },
      highlighted: false,
      autoGenerated: false,
      invalidated: true,
      isLocked: false,
      isVisible: true,
    };

    const addedAnnotation = annotation.state.addAnnotation(
      splineAnnotation,
      element
    );
    console.log("✅ Restored annotation", addedAnnotation);
  });

  // ✅ Re-render viewport so restored annotations appear
  const renderingEngine = getRenderingEngine(renderingEngineId);
  const viewport = renderingEngine.getViewport(viewportId);
  viewport.render();
}

const DicomViewer: React.FC = () => {
  const viewportRef = useRef<HTMLDivElement>(null);
  const [imageIds, setImageIds] = useState<
    { imageId: string; fileName: string }[]
  >([]);
  const [currentSlice, setCurrentSlice] = useState<number>(0);
  const [activeTool, setActiveTool] = useState<string>("SplineROI");
  const [isInitialized, setIsInitialized] = useState<boolean>(false);

  const renderingEngineRef = useRef<RenderingEngine | null>(null);
  const toolGroupRef = useRef<any>(null);

  // Initialization
  useEffect(() => {
    const init = async () => {
      await coreInit();
      await dicomImageLoaderInit();
      await toolsInit();
      addTool(SplineROITool);
      addTool(StackScrollTool);

      setIsInitialized(true);
    };
    init();
  }, []);

  // Setup Viewer
  useEffect(() => {
    if (!isInitialized || !viewportRef.current || imageIds.length === 0) return;

    const setupViewer = async () => {
      const renderingEngineId = "myRenderingEngine";
      const viewportId = "dicomViewport";
      const toolGroupId = "dicomToolGroup";

      renderingEngineRef.current?.destroy();
      try {
        ToolGroupManager.destroyToolGroup(toolGroupId);
      } catch {}

      renderingEngineRef.current = new RenderingEngine(renderingEngineId);
      const viewportInput = {
        viewportId,
        element: viewportRef.current!,
        type: ViewportType.STACK,
      };

      renderingEngineRef.current.enableElement(viewportInput);
      const viewport = renderingEngineRef.current.getViewport(viewportId);

      toolGroupRef.current = ToolGroupManager.createToolGroup(toolGroupId);
      toolGroupRef.current?.addTool(SplineROITool.toolName);
      toolGroupRef.current?.addTool(StackScrollTool.toolName);

      toolGroupRef.current?.addViewport(viewportId, renderingEngineId);

      setToolActive(activeTool);

      const ImageIdArray = imageIds.map((entry) => entry.imageId);
      console.log("viewing time", imageIds, currentSlice);
      console.log("viewing time", ImageIdArray, currentSlice);

      await viewport.setStack(ImageIdArray, currentSlice);
      viewport.render();
      const imageId = ImageIdArray[currentSlice];
      const matched = imageIds.find((entry) => entry.imageId === imageId);
      if (matched) {
        const element = viewportRef.current!;
        loadAnnotations(
          viewportId,
          renderingEngineId,
          imageId,
          matched.fileName,
          element
        );
      }
    };

    setupViewer();

    return () => {
      renderingEngineRef.current?.destroy();
      try {
        ToolGroupManager.destroyToolGroup("dicomToolGroup");
      } catch {}
    };
  }, [isInitialized, imageIds]);

  const setToolActive = (toolName: string) => {
    if (!toolGroupRef.current) return;

    toolGroupRef.current.setToolPassive(StackScrollTool.toolName);
    toolGroupRef.current.setToolPassive(SplineROITool.toolName);

    const toolMap = {
      StackScroll: StackScrollTool.toolName,
      SplineROI: SplineROITool.toolName,
    };

    const tool = toolMap[toolName];
    if (tool) {
      toolGroupRef.current.setToolActive(tool, {
        bindings: [{ mouseButton: MouseBindings.Primary }],
      });
    }
  };

  const saveAnnotations = () => {
    try {
      const element = viewportRef.current;
      if (!element || !element.isConnected) {
        console.error("Element not found or not connected");
        return;
      }

      // Get all spline annotations on the viewport
      const splineAnnotations = annotation.state.getAnnotations(
        "SplineROI",
        element
      );

      if (!splineAnnotations || splineAnnotations.length === 0) {
        console.warn("No SplineROI annotations found.");
        return;
      }

      // Find current imageId (the one being viewed)
      const enabledElement = getEnabledElement(element);
      const imageId = enabledElement?.viewport?.getCurrentImageId?.();

      if (!imageId) {
        console.error("Could not retrieve current imageId");
        return;
      }

      const matched = imageIds.find((entry) => entry.imageId === imageId);
      if (!matched) {
        console.error("Filename not found for imageId:", imageId);
        return;
      }

      const { fileName } = matched;
      const storageKey = `annotations_${fileName}`;

      // ✅ Filter: Only save annotations that belong to THIS image
      const filteredAnnotations = splineAnnotations
        .filter((ann) => ann.metadata.referencedImageId === imageId) // ✅ only current slice
        .map((ann) => ({
          toolName: ann.metadata.toolName,
          FrameOfReferenceUID: ann.metadata.FrameOfReferenceUID,
          annotationUID: ann.annotationUID,
          points: ann.data.handles.points,
        }));

      if (filteredAnnotations.length === 0) {
        console.warn("No annotations found for this slice");
        localStorage.removeItem(storageKey); // Optional: clear old data for this slice
        return;
      }

      localStorage.setItem(storageKey, JSON.stringify(filteredAnnotations));
      console.log(
        `✅ Saved ${filteredAnnotations.length} annotation(s) for ${fileName}`
      );
    } catch (error) {
      console.error("Error saving annotations:", error);
    }
  };

  const handleToolChange = (tool: string) => {
    setActiveTool(tool);
    setToolActive(tool);
  };

  const handleSliceChange = async (slice: number) => {
    setCurrentSlice(slice);
    const viewportId = "dicomViewport";
    const renderingEngineId = "myRenderingEngine";
    const viewport = renderingEngineRef.current?.getViewport(viewportId);
    const element = viewportRef.current!;
    const ImageIdArray = imageIds.map((entry) => entry.imageId);
    const imageId = ImageIdArray[slice];

    console.log("handleSliceChange", ImageIdArray, slice);

    await viewport?.setStack(ImageIdArray, slice);
    viewport?.render();

    // ✅ Load annotations for this slice
    const matched = imageIds.find((entry) => entry.imageId === imageId);
    if (matched) {
      loadAnnotations(
        viewportId,
        renderingEngineId,
        imageId,
        matched.fileName,
        element
      );
    }
  };

  return (
    <div className={styles.container}>
      <h1 className="text-2xl font-bold text-center my-4">
        DICOM Viewer with SplineROI Tool
      </h1>
      <FileUploader setImageIds={setImageIds} />
      {imageIds.length > 0 && (
        <>
          <Toolbar
            activeTool={activeTool}
            onToolChange={handleToolChange}
            onSave={saveAnnotations}
          />
          <Viewport ref={viewportRef} />
          <SliceSlider
            value={currentSlice}
            max={imageIds.length - 1}
            onChange={handleSliceChange}
          />
          <Instructions />
          <DebugInfo
            imageCount={imageIds.length}
            currentSlice={currentSlice}
            activeTool={activeTool}
          />
        </>
      )}
    </div>
  );
};

export default DicomViewer;
