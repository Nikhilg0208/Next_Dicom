"use client";

import {
  Enums,
  RenderingEngine,
  init as coreInit,
  getEnabledElement,
  getRenderingEngine,
} from "@cornerstonejs/core";
import { init as dicomImageLoaderInit } from "@cornerstonejs/dicom-image-loader";
import {
  SplineROITool,
  StackScrollTool,
  ToolGroupManager,
  addTool,
  annotation,
  Enums as csToolsEnums,
  init as toolsInit,
} from "@cornerstonejs/tools";
import React, { useEffect, useRef, useState } from "react";

import DebugInfo from "./components/DebugInfo";
import FileUploader from "./components/FileUploader";
import Instructions from "./components/Instructions";
import SliceSlider from "./components/SliceSlider";
import Toolbar from "./components/Toolbar";
import Viewport from "./components/Viewport";

import styles from "./styles/DicomViewer.module.css";

const { ViewportType } = Enums;
const { MouseBindings } = csToolsEnums;

function loadAnnotations(
  viewportId,
  renderingEngineId,
  imageId,
  fileName,
  element
) {
  // Fetch annotations from backend
  fetch(`/api/v1/get-annotation?imageId=${encodeURIComponent(imageId)}`)
    .then((res) => res.json())
    .then((result) => {
      if (
        !result.success ||
        !result.data ||
        !Array.isArray(result.data.points)
      ) {
        console.log("No annotations found for", imageId);
        return;
      }
      const annotations: Array<{
        toolName: string;
        FrameOfReferenceUID: string;
        annotationUID: string;
        points: any[];
      }> = [
        {
          toolName: result.data.toolName || "SplineROI",
          FrameOfReferenceUID: result.data.FrameOfReferenceUID || "",
          annotationUID: result.data.annotationUID || "",
          points: result.data.points.map((pt: any) => pt),
        },
      ];

      // Remove only annotations for THIS imageId
      const existingAnnotations = annotation.state.getAnnotations(
        "SplineROI",
        element
      );
      existingAnnotations
        .filter(
          (ann: any) =>
            ann && ann.metadata && ann.metadata.referencedImageId === imageId
        )
        .forEach((ann: any) => {
          if (ann && typeof ann.annotationUID === "string") {
            annotation.state.removeAnnotation(ann.annotationUID);
          }
        });

      const toolGroup = ToolGroupManager.getToolGroup("dicomToolGroup");

      annotations.forEach((ann: any) => {
        if (!toolGroup) return;
        const toolInstance = toolGroup.getToolInstance(ann.toolName);
        if (!toolInstance || !toolInstance._getSplineConfig) return;
        const originalConfig =
          toolGroup.getToolConfiguration(ann.toolName, "spline") || {};
        const splineType =
          typeof originalConfig.type === "string"
            ? originalConfig.type
            : "CARDINAL";
        const splineConfig = toolInstance._getSplineConfig(splineType);
        const SplineClass = splineConfig?.Class;
        const splineInstance = SplineClass ? new SplineClass() : undefined;

        const splineAnnotation = {
          annotationUID: ann.annotationUID || "",
          metadata: {
            referencedImageId: imageId,
            toolName: ann.toolName,
            viewportId,
            renderingEngineId,
            FrameOfReferenceUID: ann.FrameOfReferenceUID,
          },
          data: {
            handles: {
              points: Array.isArray(ann.points) ? ann.points : [],
            },
            label: "",
            cachedStats: {},
            spline: {
              type: splineType,
              instance: splineInstance,
            },
            contour: {
              closed: true,
            },
          },
          highlighted: false,
          autoGenerated: false,
          invalidated: true,
          isLocked: false,
          isVisible: true,
        };

        const addedAnnotation = annotation.state.addAnnotation(
          splineAnnotation,
          element
        );
        console.log("✅ Restored annotation", addedAnnotation);
      });

      // Re-render viewport so restored annotations appear
      const renderingEngine = getRenderingEngine(renderingEngineId);
      if (renderingEngine) {
        const viewport = renderingEngine.getViewport(viewportId);
        if (viewport && typeof viewport.render === "function") {
          viewport.render();
        }
      }
    })
    .catch((err) => {
      console.error("Error loading annotations from backend:", err);
    });

  // ✅ Remove only annotations for THIS imageId (instead of clearing all)
  const existingAnnotations = annotation.state.getAnnotations(
    "SplineROI",
    element
  );
  existingAnnotations
    .filter((ann) => ann.metadata.referencedImageId === imageId)
    .forEach((ann) => annotation.state.removeAnnotation(ann.annotationUID));

  const toolGroup = ToolGroupManager.getToolGroup("dicomToolGroup");

  annotations.forEach((ann) => {
    // ann.metadata.toolName
    // imageId
    // ann.metadata.FrameOfReferenceUID
    // annotationUID
    // ann.data.handles.points
    const toolInstance = toolGroup.getToolInstance(ann.toolName);

    const originalConfig = toolGroup.getToolConfiguration(
      ann.toolName,
      "spline"
    );
    const splineType = originalConfig?.type || "CARDINAL";
    const splineConfig = toolInstance._getSplineConfig(splineType);
    const SplineClass = splineConfig.Class;
    const splineInstance = new SplineClass();

    // ✅ Build restored annotation object
    const splineAnnotation = {
      annotationUID: ann.annotationUID,
      metadata: {
        referencedImageId: imageId,
        toolName: ann.toolName,
        viewportId,
        renderingEngineId,
        FrameOfReferenceUID: ann.FrameOfReferenceUID,
      },
      data: {
        handles: {
          points: ann.points,
        },
        label: "",
        cachedStats: {},
        spline: {
          type: splineType,
          instance: splineInstance,
        },
        contour: {
          closed: true,
        },
      },
      highlighted: false,
      autoGenerated: false,
      invalidated: true,
      isLocked: false,
      isVisible: true,
    };

    const addedAnnotation = annotation.state.addAnnotation(
      splineAnnotation,
      element
    );
    console.log("✅ Restored annotation", addedAnnotation);
  });

  // ✅ Re-render viewport so restored annotations appear
  const renderingEngine = getRenderingEngine(renderingEngineId);
  const viewport = renderingEngine.getViewport(viewportId);
  viewport.render();
}

const DicomViewer: React.FC = () => {
  const viewportRef = useRef<HTMLDivElement>(null);
  const [imageIds, setImageIds] = useState<
    { imageId: string; fileName: string }[]
  >([]);
  const [currentSlice, setCurrentSlice] = useState<number>(0);
  const [activeTool, setActiveTool] = useState<string>("SplineROI");
  const [isInitialized, setIsInitialized] = useState<boolean>(false);

  const renderingEngineRef = useRef<RenderingEngine | null>(null);
  const toolGroupRef = useRef<any>(null);

  // Initialization
  useEffect(() => {
    const init = async () => {
      await coreInit();
      await dicomImageLoaderInit();
      await toolsInit();
      addTool(SplineROITool);
      addTool(StackScrollTool);

      setIsInitialized(true);
    };
    init();
  }, []);

  // Setup Viewer
  useEffect(() => {
    if (!isInitialized || !viewportRef.current || imageIds.length === 0) return;

    const setupViewer = async () => {
      const renderingEngineId = "myRenderingEngine";
      const viewportId = "dicomViewport";
      const toolGroupId = "dicomToolGroup";

      renderingEngineRef.current?.destroy();
      try {
        ToolGroupManager.destroyToolGroup(toolGroupId);
      } catch {}

      renderingEngineRef.current = new RenderingEngine(renderingEngineId);
      const viewportInput = {
        viewportId,
        element: viewportRef.current!,
        type: ViewportType.STACK,
      };

      renderingEngineRef.current.enableElement(viewportInput);
      const viewport = renderingEngineRef.current.getViewport(viewportId);

      toolGroupRef.current = ToolGroupManager.createToolGroup(toolGroupId);
      toolGroupRef.current?.addTool(SplineROITool.toolName);
      toolGroupRef.current?.addTool(StackScrollTool.toolName);

      toolGroupRef.current?.addViewport(viewportId, renderingEngineId);

      setToolActive(activeTool);

      const ImageIdArray = imageIds.map((entry) => entry.imageId);
      console.log("viewing time", imageIds, currentSlice);
      console.log("viewing time", ImageIdArray, currentSlice);

      await viewport.setStack(ImageIdArray, currentSlice);
      viewport.render();
      const imageId = ImageIdArray[currentSlice];
      const matched = imageIds.find((entry) => entry.imageId === imageId);
      if (matched) {
        const element = viewportRef.current!;
        loadAnnotations(
          viewportId,
          renderingEngineId,
          imageId,
          matched.fileName,
          element
        );
      }
    };

    setupViewer();

    return () => {
      renderingEngineRef.current?.destroy();
      try {
        ToolGroupManager.destroyToolGroup("dicomToolGroup");
      } catch {}
    };
  }, [isInitialized, imageIds]);

  const setToolActive = (toolName: string) => {
    if (!toolGroupRef.current) return;

    toolGroupRef.current.setToolPassive(StackScrollTool.toolName);
    toolGroupRef.current.setToolPassive(SplineROITool.toolName);

    const toolMap = {
      StackScroll: StackScrollTool.toolName,
      SplineROI: SplineROITool.toolName,
    };

    const tool = toolMap[toolName];
    if (tool) {
      toolGroupRef.current.setToolActive(tool, {
        bindings: [{ mouseButton: MouseBindings.Primary }],
      });
    }
  };

  const saveAnnotations = () => {
    try {
      const element = viewportRef.current;
      if (!element || !element.isConnected) {
        console.error("Element not found or not connected");
        return;
      }

      // Get all spline annotations on the viewport
      const splineAnnotations = annotation.state.getAnnotations(
        "SplineROI",
        element
      );

      if (!splineAnnotations || splineAnnotations.length === 0) {
        console.warn("No SplineROI annotations found.");
        return;
      }

      // Find current imageId (the one being viewed)
      const enabledElement = getEnabledElement(element);
      const imageId = enabledElement?.viewport?.getCurrentImageId?.();

      if (!imageId) {
        console.error("Could not retrieve current imageId");
        return;
      }

      const matched = imageIds.find((entry) => entry.imageId === imageId);
      if (!matched) {
        console.error("Filename not found for imageId:", imageId);
        return;
      }

      const { fileName } = matched;

      // Only save annotations that belong to THIS image
      const filteredAnnotations = splineAnnotations
        .filter((ann: any) => ann?.metadata?.referencedImageId === imageId)
        .map((ann: any) => ({
          toolName: ann?.metadata?.toolName || "SplineROI",
          FrameOfReferenceUID: ann?.metadata?.FrameOfReferenceUID || "",
          annotationUID: ann?.annotationUID || "",
          points: ann?.data?.handles?.points || [],
          imageId,
          fileName,
        }));

      if (filteredAnnotations.length === 0) {
        console.warn("No annotations found for this slice");
        return;
      }

      // Send all annotations in a single POST request
      fetch("/api/v1/add-annotation", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ annotations: filteredAnnotations }),
      })
        .then((res) => res.json())
        .then((result) => {
          if (result.success) {
            console.log("✅ Saved annotations to backend", result.data);
          } else {
            console.error("Failed to save annotations:", result.message);
          }
        })
        .catch((err) => {
          console.error("Error saving annotations to backend:", err);
        });
    } catch (error) {
      console.error("Error saving annotations:", error);
    }
  };

  const handleToolChange = (tool: string) => {
    setActiveTool(tool);
    setToolActive(tool);
  };

  const handleSliceChange = async (slice: number) => {
    setCurrentSlice(slice);
    const viewportId = "dicomViewport";
    const renderingEngineId = "myRenderingEngine";
    const viewport = renderingEngineRef.current?.getViewport(viewportId);
    const element = viewportRef.current!;
    const ImageIdArray = imageIds.map((entry) => entry.imageId);
    const imageId = ImageIdArray[slice];

    console.log("handleSliceChange", ImageIdArray, slice);

    await viewport?.setStack(ImageIdArray, slice);
    viewport?.render();

    // ✅ Load annotations for this slice
    const matched = imageIds.find((entry) => entry.imageId === imageId);
    if (matched) {
      loadAnnotations(
        viewportId,
        renderingEngineId,
        imageId,
        matched.fileName,
        element
      );
    }
  };

  return (
    <div className={styles.container}>
      <h1 className="text-2xl font-bold text-center my-4">
        DICOM Viewer with SplineROI Tool
      </h1>
      <FileUploader setImageIds={setImageIds} />
      {imageIds.length > 0 && (
        <>
          <Toolbar
            activeTool={activeTool}
            onToolChange={handleToolChange}
            onSave={saveAnnotations}
          />
          <Viewport ref={viewportRef} />
          <SliceSlider
            value={currentSlice}
            max={imageIds.length - 1}
            onChange={handleSliceChange}
          />
          <Instructions />
          <DebugInfo
            imageCount={imageIds.length}
            currentSlice={currentSlice}
            activeTool={activeTool}
          />
        </>
      )}
    </div>
  );
};

export default DicomViewer;
